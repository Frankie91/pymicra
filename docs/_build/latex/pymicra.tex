% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[a4paper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{pymicra Documentation}
\date{Jul 21, 2016}
\release{0.2.0}
\author{Tom√°s Chor}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


This package was designed to make it easier to work with
micrometeorological data. Pymicra is currently fully written in python
and it's aimed towards aggregating all of functionality that is commonly
needed to work with micrometeorological data into one
productivity-enhancing tool.

The package is extensively (almost entirely) based on Pandas, mostly the
\sphinxcode{pandas.DataFrame} class. We use Pint for units control and
(generally) Numpy or Scipy for some numerical functions not contained in
Pandas.


\chapter{Required Packages}
\label{index:pymicra-a-python-tool-for-micrometeorological-analyses}\label{index:required-packages}
Most required packages already come with python. However, packages that
generally have to be manually installed beforehand are:
\begin{itemize}
\item {} 
Pandas

\item {} 
Pint

\item {} 
Numpy

\item {} 
Scipy

\item {} 
setuptools (for installation only)

\end{itemize}


\chapter{Main Features}
\label{index:main-features}
Currently, this is a sum up of what Pymicra does:
\begin{itemize}
\item {} 
Reading, separating and understanding micrometeorological data in
virtually any column-separated ASCII format (thanks to pandas).

\item {} 
Quality control methods (max and min values check, spikes,
reverse-arrangement test and etc..

\item {} 
Rotation of coordinates (2D).

\item {} 
Detrending of data in the most common ways (block averages, moving
averages and polynomial detrending).

\item {} 
Correction of sensor drift.

\item {} 
Automatic calculation of most auxiliary variables based on actual
measurements (air density, dry air density, etc.).

\item {} 
Calculation of spectra and cross-spectra.

\item {} 
Calculation fluxes and characteristic scales.

\item {} 
WPL correction.

\item {} 
Provide all the common constants generally used in micrometeorology.

\item {} 
Plus all native features of Pandas (interpolation, resampling,
grouping, statistical tests, slicing, handling of missing data and
etc.)

\end{itemize}

Contents:


\section{Introduction}
\label{intro:introduction}\label{intro::doc}
section\{Presentation\}

This material is meant to be a quick introduction to the Python tool for
Micrometeorological Analyses (Pymicra). Since the package is currently in an
experimental state, it is impossible for me to include 100\% of the
functions contained in Pymicra in this guide because new functions are
constantly being created. However, the most important classes, functions and
capabilities are described here and the user is encouraged to interactively use
the Pymicra and refer to the docstrings in the code to learn more.

Pymicra is a Python package that was created to condense many of the knowledge
of the micrometeorological community in one single fast-to-implement software
that is freely available to anyone. Because of that, I made an effort to include
a detailed docstring along with every function and class, so if you import the
package and run texttt\{help(pymicra.timeSeries)\}, for example, you will see a
detailed description of what the function texttt\{timeSeries\} does and so on for
any other functions. It is a good idea to import Pymicra using the IPython
terminal and use its autocomplete function by hitting tab after typing
texttt\{pymicra.\} to see and explore the available functions.

Since Pymicra is meant to be a community package, improvements, suggestions of
improvement, and any kind of feedback are highly appreciated. The code is
available at href\{\url{https://github.com/tomchor/pymicra}\}\{its github page\} and any
contact can be made through there (possibly creating an issue) or via e-mail.

section\{Description and suggestions\}

In order for the user to program fast and effectively (and to reduce the time it
takes me to write its code), Pymicra was written on top of the
href\{\url{http://pandas.pydata.org/}\}\{Pandas package\}, so that it is faster to run
the same code using Pymicra than it is running pure Python. As a consequence,
Pymicra makes extensive use of Pandas' DataFrame class, which is a very useful
2-D data structure optimized for performance and for timestamp-indexed data.

It is possible to use Pymicra without having to be familiar with Pandas, but
because Pymicra depends on Pandas, I suggest at the very least that the user
take a quick look at a Pandas tutorial
(href\{\url{http://pandas.pydata.org/pandas-docs/stable/10min.html}\}\{this one for
example\}) so that one can be familiarized with the many functionalities that
Pandas offers in order to take full advantage of Pymicra.


\section{Installation}
\label{install:installation}\label{install::doc}
\begin{notice}{warning}{Warning:}
The commands written here assume you are running a Ubuntu-based distribution of
Linux. Although the basic steps should be similar for all Linux distributions, you
should adapt the specific commands to your system in case you are using any other Linux distro.
\end{notice}

In order to install Pymicra the \sphinxcode{setuptools} Python package should be
installed. If you don't have it installed already you can install it with
\sphinxcode{sudo apt install python-setuptools} or \sphinxcode{sudo pip install setuptools}.

Download the package an unpack in somewhere. Then open a terminal and
move to the directory created, whose name should be \sphinxcode{pymicra}. Then
run \sphinxcode{sudo python setup.py install}. This should be enough to install
the package.

First download the zipped file at the href\{github.com/tomchor/pymicra\}\{Pymicra
github page\} and unzip it somewhere. Then, using a
terminal, move to the unzipped directory and run the setup file
(texttt\{setup.py\}) with
root access: texttt\{sudo python setup.py install\}. For this to work you must
have setuptools installed, which can be promptly done using texttt\{sudo apt-get
install python-setuptools\}. This should successfully install Pymicra. The only
requirements are Pandas and Pint. Version 0.17 of Pandas is suggested, but it
should work fine will any distribution from 0.13 up to 0.17.1 (0.18 is not
supported because of changed in the rolling functions API).

Although fairly general, I have tested the setup program on a limited number of
computers so far, so it is possible that an error occurs depending on the
version of some auxiliary packages you have installed. If that happens and the
installation fails for some reason, please contact me through email or creating
a github issue detailing your problem and I will improve the setup file.

Alternatively, while the installation cannot be done, you can add the package
manually to your Python path by adding the following lines to the beginning of your
Python code:

begin\{lstlisting\}
import sys
sys.path.append(`/full/path/to/pymicra')
end\{lstlisting\}

and then proceed to import Pymicra normally.

To remove Pymicra, the easiest way is to use pip
(\sphinxcode{sudo apt-get install python-pip}) with the command
\sphinxcode{sudo pip uninstall pymicra}.


\section{Notation}
\label{notation::doc}\label{notation:notation}
Pymicra uses a specific notation to name each one of its columns. This notation
is extremely important, because it is by these labels that Pymicra knows which
variable is in each column, so we advise at the very least a quick look at this chapter to
understand the basics of naming.

The notation can be checked by opening the IPython terminal (because of its
autocomplete function) and entering

begin\{terminal\}
begin\{alltt\}
import pymicra
dir(pymicra.notation)
end\{alltt\}
end\{terminal\}

You can change Pymicra's notation at any time by altering the attributes of
texttt\{pymicra.notation\}. Some examples are


\section{Getting started}
\label{tutorial:getting-started}\label{tutorial::doc}

\subsection{Reading datafiles}
\label{tutorial:reading-datafiles}
The easiest way to read data files is using a Pymicra class called
texttt\{dataloggerConfig\} along with the function texttt\{timeSeries\}. First,
let's explain what the texttt\{dataloggerConfig\} class does. This class holds
most of the configurations inherent to the datalogger that actually influence
the file output (such as columns separator), which variable is in each column,
variables units, frequency, file headers, etc..

You can create a texttt\{dataloggerConfig\} object manually by passing each of
these informations as a keyword to the texttt\{dataloggerConfig\} function, but
the easiest method is to create a texttt\{.dlc\} file (meaning datalogger
configuration), store it somewhere and create a texttt\{dataloggerConfig\} object
by reading it every time you work with files with that same configuration.

Consider the example texttt\{.dlc\} file below, which will be explained next.

lstinputlisting\{ex\_itaipu.dlc\}

First of all, every .dlc file is writen in Python syntax, so it has to be able
to actually be run on python. The description is optional and the
texttt\{first\_time\_skip\} and texttt\{date\_connector\} keywords are generally
not necessary, so you'll rarely have to use them. They can be omitted from the
file.

The most important keyword is texttt\{varNames\}. Since Pymicra works with labels for its
data, its best if all the names of the variables are properly writen, preferably
following the default Pymicra notation. Let look at how to write parts of the
timestamp first.

The columns that contain parts of the date have to have their name matching
Python's
href\{\url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}\}\{date
format string directive\}. This is useful in case you want to index your data by
timestamp, which is a huge advantage in some cases (check out what Pandas can do
with
href\{\url{http://pandas.pydata.org/pandas-docs/stable/timeseries.html}\}\{timestamp-indexed
data\}). If you don't wish to work with timestamps and want to work only by line
number in each file, you can ignore there columns.

As for the physical quantities, it is strongly advised to follow Pymicra's
notation, which is described in Pymicra's README.md file and explained in
Chapter ref\{chap:notation\}. In the above example, which follows the Pymicra
notation, u, v and w are the three wind components, texttt\{theta\_v\} stands for
the virtual temperature, and texttt\{mrho\_h2o\} stands for the molar density of
H2O. If it were the mass density the name would have been texttt\{rho\_h2o\},
according to the notation.

The texttt\{date\_cols\}

The texttt\{frequency\}, in Hertz, is the frequency of the data collection.
Useful mostly when taking the spectrum or cospectrum.

The texttt\{columns\} separator is what separates one column from the other.
Generaly it is one character, such as a comma or a whitespace. A special case
happens is if the columns are separated by whitespaces of varying length. In
that case just put {\color{red}\bfseries{}{}`{}`}whitespace'`.

The keyword texttt\{header\_lines\} is an int, or list of ints saying which rows
are headers, starting from zero. So if the first two rows of the file are a
header, the texttt\{header\_lines\} in this case should be texttt\{{[}0, 1{]}\}.

The tt\{filename\_format\}

The tt\{date\_connector\}

The tt\{first\_time\_skip\}

With this file ready, it is easy to read any datafile. Consider the example
below

EXAMPLE

In it we passed the path of a file to read and the tt\{dataloggerConfig\} object
containing the configuration of the file. The function tt\{timeSeries\} reads the
file according to the options provided and returns a DataFrame that is put into
the tt\{data\} variable. Printing tt\{data\}, in this case, would print the
following on screen.

DATA PRINT

Notice that every variable defined in our datalogger configuration file appears in the
data variable.

chapter\{Viewing and manipulating data\}

To view and manipulate data you have to follow Pandas's DataFrame rules. For
that we suggest that the user visit a Pandas tutorial. However, I'll explain
some main ideas here for the sake of completeness.

chapter\{Extracting fluxes\}


\section{Pymicra's auto-generated docs}
\label{pymicra:pymicra-s-auto-generated-docs}\label{pymicra::doc}

\subsection{Subpackages}
\label{pymicra:subpackages}

\subsection{Submodules}
\label{pymicra:submodules}

\subsection{pymicra.constants module}
\label{pymicra:module-pymicra.constants}\label{pymicra:pymicra-constants-module}\index{pymicra.constants (module)}
Defines some useful constants


\subsection{pymicra.core module}
\label{pymicra:module-pymicra.core}\label{pymicra:pymicra-core-module}\index{pymicra.core (module)}\index{Notation (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{Notation}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This creates an object that holds the default notation for pymicra.
Example of usage:

notation = notation()

fluctuations\_of\_co2\_conc = notation.concentration \% notation.fluctuations \% notation.co2

You should be careful with the order. The last argument should not have any `\%' symbols
or you'll get a ``TypeError: not all arguments converted during string formatting'' message.
\paragraph{Methods}
\index{build() (pymicra.core.Notation method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.build}\pysiglinewithargsret{\sphinxbfcode{build}}{}{}
This useful method builds the full notation based on the base notation

\end{fulllineitems}

\index{concentration (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.concentration}\pysigline{\sphinxbfcode{concentration}\sphinxstrong{ = `conc\_\%s'}}
\end{fulllineitems}

\index{cospectrum (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.cospectrum}\pysigline{\sphinxbfcode{cospectrum}\sphinxstrong{ = `Co\_\%s\_\%s'}}
\end{fulllineitems}

\index{cross\_spectrum (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.cross_spectrum}\pysigline{\sphinxbfcode{cross\_spectrum}\sphinxstrong{ = `X\_\%s\_\%s'}}
\end{fulllineitems}

\index{density (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.density}\pysigline{\sphinxbfcode{density}\sphinxstrong{ = `rho\_\%s'}}
\end{fulllineitems}

\index{fluctuations (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.fluctuations}\pysigline{\sphinxbfcode{fluctuations}\sphinxstrong{ = ``\%s'''}}
\end{fulllineitems}

\index{flux\_of (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.flux_of}\pysigline{\sphinxbfcode{flux\_of}\sphinxstrong{ = `F\_\%s'}}
\end{fulllineitems}

\index{mass\_concentration (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mass_concentration}\pysigline{\sphinxbfcode{mass\_concentration}\sphinxstrong{ = `conc\_\%s'}}
\end{fulllineitems}

\index{mass\_density (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mass_density}\pysigline{\sphinxbfcode{mass\_density}\sphinxstrong{ = `rho\_\%s'}}
\end{fulllineitems}

\index{mass\_mixing\_ratio (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mass_mixing_ratio}\pysigline{\sphinxbfcode{mass\_mixing\_ratio}\sphinxstrong{ = `r\_\%s'}}
\end{fulllineitems}

\index{mean (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mean}\pysigline{\sphinxbfcode{mean}\sphinxstrong{ = `\%s\_mean'}}
\end{fulllineitems}

\index{mixing\_ratio (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mixing_ratio}\pysigline{\sphinxbfcode{mixing\_ratio}\sphinxstrong{ = `r\_\%s'}}
\end{fulllineitems}

\index{molar\_concentration (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.molar_concentration}\pysigline{\sphinxbfcode{molar\_concentration}\sphinxstrong{ = `mconc\_\%s'}}
\end{fulllineitems}

\index{molar\_density (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.molar_density}\pysigline{\sphinxbfcode{molar\_density}\sphinxstrong{ = `mrho\_\%s'}}
\end{fulllineitems}

\index{molar\_mixing\_ratio (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.molar_mixing_ratio}\pysigline{\sphinxbfcode{molar\_mixing\_ratio}\sphinxstrong{ = `mr\_\%s'}}
\end{fulllineitems}

\index{quadrature (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.quadrature}\pysigline{\sphinxbfcode{quadrature}\sphinxstrong{ = `Qu\_\%s\_\%s'}}
\end{fulllineitems}

\index{spectrum (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.spectrum}\pysigline{\sphinxbfcode{spectrum}\sphinxstrong{ = `Sp\_\%s'}}
\end{fulllineitems}

\index{star (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.star}\pysigline{\sphinxbfcode{star}\sphinxstrong{ = `\%s\_star'}}
\end{fulllineitems}

\index{std (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.std}\pysigline{\sphinxbfcode{std}\sphinxstrong{ = `\%s\_std'}}
\end{fulllineitems}


\end{fulllineitems}

\index{dataloggerConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.dataloggerConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{dataloggerConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This class defines a specific configuration of a datalogger output file
\begin{description}
\item[{from\_file: str}] \leavevmode
path of .dlc file (datalogger configuration file) to read from. This will ignore all other
keywords.

\item[{varNames: list of strings or dict}] \leavevmode
If a list: should be a list of strings with the names of the variables. If the variable
is part if the date, then it should be provided as a datetime directive,
so if the columns is only the year, its name must be \sphinxtitleref{\%Y} and so forth. While
if it is the date in YYYY/MM/DD format, it should be \sphinxtitleref{\%Y/\%m/\%d}. For more info
see \url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}
If a dict: the keys should be the numbers of the columns and the items should follow
the rules for a list.

\item[{date\_cols: list of ints}] \leavevmode
should be indexes of the subset of varNames that corresponds to the variables that compose
the timestamp. If it is not provided the program will try to guess by getting
all variable names that have a percentage sign (\%).

\item[{date\_connector: string}] \leavevmode
generally not really necessary. It is used to join and then parse the date\_cols.

\item[{columns\_separator: string}] \leavevmode
used to assemble the date. Should only be used if the default char creates conflict. If
the file is tabular-separated then this should be ``whitespace''.

\item[{header\_lines: int}] \leavevmode
up to which line of the file is a header. See pandas.read\_csv header option.

\item[{first\_time\_skip: int}] \leavevmode
how many units of frequency the first line of the file is offset (generally zero).

\item[{filename\_format: string}] \leavevmode
tells the format of the file with the standard notation for date and time and with variable
parts as ''?''. E.g. if the files are 56\_20150101.csv, 57\_20150102.csv etc filename\_format should be:
\begin{quote}

??\_\%Y\%m\%d.csv
\end{quote}

this is useful primarily for the quality control feature.

\item[{units: dictionary}] \leavevmode
very important: a dictionary whose keys are the columns of the file and whose items are
the units in which they appear.

\item[{description: string}] \leavevmode
brief description of the datalogger configuration file.

\end{description}

\end{fulllineitems}

\index{fileConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{fileConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This class defines a specific configuration of a data file
\begin{description}
\item[{from\_file: str}] \leavevmode
path of .cfg file (configuration file) to read from. This will ignore all other
keywords.

\item[{variables: list of strings or dict}] \leavevmode
If a list: should be a list of strings with the names of the variables. If the variable
is part if the date, then it should be provided as a datetime directive,
so if the columns is only the year, its name must be \sphinxtitleref{\%Y} and so forth. While
if it is the date in YYYY/MM/DD format, it should be \sphinxtitleref{\%Y/\%m/\%d}. For more info
see \url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}
If a dict: the keys should be the numbers of the columns and the items should follow
the rules for a list.

\item[{date\_cols: list of ints}] \leavevmode
should be indexes of the subset of varNames that corresponds to the variables that compose
the timestamp. If it is not provided the program will try to guess by getting
all variable names that have a percentage sign (\%).

\item[{date\_connector: string}] \leavevmode
generally not really necessary. It is used to join and then parse the date\_cols.

\item[{columns\_separator: string}] \leavevmode
used to assemble the date. If the file is tabular-separated then this should be ``whitespace''.

\item[{header\_lines: int or list}] \leavevmode
up to which line of the file is a header. See pandas.read\_csv header option.

\item[{filename\_format: string}] \leavevmode
tells the format of the file with the standard notation for date and time and with variable
parts as ''?''. E.g. if the files are 56\_20150101.csv, 57\_20150102.csv etc filename\_format should be:
\begin{quote}

??\_\%Y\%m\%d.csv
\end{quote}

this is useful primarily for the quality control feature.

\item[{units: dictionary}] \leavevmode
very important: a dictionary whose keys are the columns of the file and whose items are
the units in which they appear.

\item[{description: string}] \leavevmode
brief description of the datalogger configuration file.

\item[{varNames: DEPRECATED}] \leavevmode
use variables now.

\end{description}
\paragraph{Methods}
\index{check\_consistency() (pymicra.core.fileConfig method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig.check_consistency}\pysiglinewithargsret{\sphinxbfcode{check\_consistency}}{}{}
Checks consistency of fileConfig
Currently only checks every key of self.units dictionary agaisnt values of variables dict.

\end{fulllineitems}

\index{get\_date\_cols() (pymicra.core.fileConfig method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig.get_date_cols}\pysiglinewithargsret{\sphinxbfcode{get\_date\_cols}}{}{}
Guesses what are the columns that contain the dates by searching
for percentage signs in them

\end{fulllineitems}


\end{fulllineitems}

\index{myData (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.myData}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{myData}}{\emph{df}, \emph{dic}}{}
Bases: \sphinxcode{object}

Attempt to create a myData object

\end{fulllineitems}

\index{siteConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.siteConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{siteConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

Keeper of the configurations and constants of an experiment. (such as height of instruments,
location, canopy height and etc)

\end{fulllineitems}



\subsection{pymicra.data module}
\label{pymicra:pymicra-data-module}\label{pymicra:module-pymicra.data}\index{pymicra.data (module)}\index{bulkCorr() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.bulkCorr}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{bulkCorr}}{\emph{data}}{}
Bulk correlation coefficient according to
Cancelli, Dias, Chamecki. Dimensionless criteria for the production of...
doi:10.1029/2012WR012127

\end{fulllineitems}

\index{crossSpectra() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.crossSpectra}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{crossSpectra}}{\emph{data}, \emph{frequency=10}, \emph{notation=None}, \emph{anti\_aliasing=True}}{}
Calculates the spectrum for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data: pandas.DataFrame or pandas.Series}
\begin{quote}

dataframe with one (will return the spectrum) or two (will return to cross-spectrum) columns
\end{quote}

\textbf{frequency: float}
\begin{quote}

frequency of measurement of signal to pass to numpy.fft.rfftfreq
\end{quote}

\textbf{anti\_aliasing: bool}
\begin{quote}

whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)
\end{quote}

\textbf{notation: notation object}
\begin{quote}

notation to be used
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{detrend() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.detrend}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{detrend}}{\emph{*args}, \emph{**kwargs}}{}
Returns the detrended fluctuations of a given dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data: pandas.DataFrame, pandas.Series}
\begin{quote}

dataset to be detrended
\end{quote}

\textbf{how: string}
\begin{quote}

how of average to apply. Currently \{`movingmean', `movingmedian', `block', `linear', `poly'\}.
\end{quote}

\textbf{rule: pandas offset string}
\begin{quote}

the blocks for which the trends should be calculated in the block and linear type
\end{quote}

\textbf{window: pandas date offset string or int}
\begin{quote}

if moving mean/median is chosen, this tells us the window size to pass to pandas. If int,
this is the number of points used in the window. If string we will to guess the number of
points from the index.
Small windows (equivalent to 1min approx) work better when using rollingmedian.
\end{quote}

\textbf{block\_func: str, function}
\begin{quote}

how to resample in block type. Default is mean but it can be any numpy function
that returns a float. E.g, median.
\end{quote}

\textbf{degree: int}
\begin{quote}

degree of polynomial fit (only if how=='linear' or how=='polynomial')
\end{quote}

\textbf{Returns:}
\begin{quote}

out: pandas.DataFrame or pandas.Series
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse\_arrangement() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.reverse_arrangement}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{reverse\_arrangement}}{\emph{array}, \emph{points\_number=None}, \emph{alpha=0.05}, \emph{verbose=False}}{}
Performs the reverse arrangement test
according to Bendat and Piersol - Random Data - 4th edition, page 96
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{array: np.array, list, tuple, generator}
\begin{quote}

array which to test for the reverse arrangement test
\end{quote}

\textbf{points\_number: integer}
\begin{quote}

number of chunks to consider to the test. Maximum is the length of the array.
If it is less, then the number of points will be reduced by application of a mean
\end{quote}

\textbf{alpha: float}
\begin{quote}

Significance level for which to apply the test
\end{quote}

\textbf{WARNING! This fuction approximates table A.6 from Bendat\&Piersol as a normal distribution.}

\textbf{This may no be true, since they do not express which distribution they use to construct}

\textbf{their table. However, in the range 9\textless{}N\textless{}101, this approximation is as good as 5\% at N=10}

\textbf{and 0.1\% at N=100.}

\textbf{Still not adapted for dataframes}

\end{description}\end{quote}

\end{fulllineitems}

\index{rotate2D() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.rotate2D}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{rotate2D}}{\emph{data}, \emph{notation=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data: pandas DataFrame}
\begin{quote}

the dataFrame to be rotated
\end{quote}

\textbf{notation: notation object}
\begin{quote}

a notation object to know which are the wind variables
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{spectra() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.spectra}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{spectra}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the cross-spectra for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data: pandas.DataFrame or pandas.Series}
\begin{quote}

dataframe with more than one columns
\end{quote}

\textbf{frequency: float}
\begin{quote}

frequency of measurement of signal to pass to numpy.fft.rfftfreq
\end{quote}

\textbf{anti\_aliasing: bool}
\begin{quote}

whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{spectrum() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.spectrum}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{spectrum}}{\emph{data}, \emph{frequency=10}, \emph{anti\_aliasing=False}, \emph{outname=None}}{}
Calculates the spectrum for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data: pandas.DataFrame}
\begin{quote}

dataframe with one (will return the spectrum) or two (will return to cross-spectrum) columns
\end{quote}

\textbf{frequency: float}
\begin{quote}

frequency of measurement of signal to pass to numpy.fft.rfftfreq
\end{quote}

\textbf{anti\_aliasing: bool}
\begin{quote}

whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)
\end{quote}

\textbf{outname: str}
\begin{quote}

name of the output column
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{trend() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.trend}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{trend}}{\emph{*args}, \emph{**kwargs}}{}
Wrapper to return the trend given data. Can be achieved using a moving avg, block avg or polynomial fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data: pandas.DataFrame or pandas.Series}
\begin{quote}

the data whose trend wee seek.
\end{quote}

\textbf{how: string}
\begin{quote}

how of average to apply. Currently \{`movingmean', `movingmedian', `block', `linear'\}.
\end{quote}

\textbf{rule: string}
\begin{quote}

pandas offset string to define the block in the block average. Default is ``10min''.
\end{quote}

\textbf{window: pandas date offset string or int}
\begin{quote}

if moving mean/median is chosen, this tells us the window size to pass to pandas. If int,
this is the number of points used in the window. If string we will to guess the number of
points from the index.
Small windows (equivalent to 1min approx) work better when using rollingmedian.
\end{quote}

\textbf{block\_func: str, function}
\begin{quote}

how to resample in block type. Default is mean but it can be any numpy function
that returns a float. E.g, median.
\end{quote}

\textbf{degree: int}
\begin{quote}

degree of polynomial fit (only if how=='linear' or how=='polynomial')
\end{quote}

\textbf{Returns:}
\begin{quote}

out: pandas.DataFrame or pandas.Series
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{pymicra.decorators module}
\label{pymicra:pymicra-decorators-module}\label{pymicra:module-pymicra.decorators}\index{pymicra.decorators (module)}\index{autoassign() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.autoassign}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{autoassign}}{\emph{function}}{{ $\rightarrow$ method}}
autoassign({\color{red}\bfseries{}*}argnames) -\textgreater{} decorator
autoassign(exclude=argnames) -\textgreater{} decorator

allow a method to assign (some of) its arguments as attributes of
`self' automatically.  E.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{Foo}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nd}{@autoassign}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{foo}\PYG{p}{,} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{:} \PYG{k}{pass}
\PYG{g+gp}{... }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{breakfast} \PYG{o}{=} \PYG{n}{Foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eggs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{breakfast}\PYG{o}{.}\PYG{n}{foo}\PYG{p}{,} \PYG{n}{breakfast}\PYG{o}{.}\PYG{n}{bar}
\PYG{g+go}{(\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}eggs\PYGZsq{})}
\end{Verbatim}

To restrict autoassignment to `bar' and `baz', write:
\begin{quote}

@autoassign(`bar', `baz')
def method(self, foo, bar, baz): ...
\end{quote}

To prevent `foo' and `baz' from being autoassigned, use:
\begin{quote}

@autoassign(exclude=(`foo', `baz'))
def method(self, foo, bar, baz): ...
\end{quote}

\end{fulllineitems}

\index{pdgeneral() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral}}{\emph{convert\_out=True}}{}
\end{fulllineitems}

\index{pdgeneral\_in() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral_in}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral\_in}}{\emph{func}}{}
\end{fulllineitems}

\index{pdgeneral\_io() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral_io}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral\_io}}{\emph{func}}{}
If the input is a series transform it to a dtaframe then transform the output from dataframe
back into a series. If the input is a series and the output is a one-element series, transform it to a float.

Currently the output functionality works only when the output is one variable, not an array
of elements.

\end{fulllineitems}



\subsection{pymicra.io module}
\label{pymicra:module-pymicra.io}\label{pymicra:pymicra-io-module}\index{pymicra.io (module)}
Author: Tomas Chor
Date: 2015-08-07
-------------------------
\index{dataset() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.dataset}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{dataset}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{readDataFile() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readDataFile}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readDataFile}}{\emph{fname}, \emph{variables=None}, \emph{only\_named\_cols=True}, \emph{**kwargs}}{}
Author: Tomas Chor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{kwargs: dict}
\begin{quote}

dictionary with kwargs of pandas' read\_csv function
see \url{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read\_csv.html} for more detail
\end{quote}

\textbf{variables: list or dict}
\begin{quote}

list or dictionary containing the names of each variable in the file (if dict, the keys must be ints)
\end{quote}

\item[{Returns}] \leavevmode
dataFrame: pandas.DataFrame object

\end{description}\end{quote}

\end{fulllineitems}

\index{readDataFiles() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readDataFiles}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readDataFiles}}{\emph{flist}, \emph{verbose=0}, \emph{**kwargs}}{}
Author: Tomas Chor
Reads data from a list of files

\end{fulllineitems}

\index{readUnitsCsv() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readUnitsCsv}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readUnitsCsv}}{\emph{filename}, \emph{**kwargs}}{}
Reads a csv file in which the first line is the name of the variables
and the second line contains the units

\end{fulllineitems}

\index{read\_dlc() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_dlc}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_dlc}}{\emph{dlcfile}}{}
Reads datalogger configuration file

WARNING! When defining the .dlc note that by default columns that are enclosed between doublequotes
will appear without the doublequotes. So if your file is of the form :

``2013-04-05 00:00:00'', .345, .344, ...

Then the .dlc should have: varNames={[}'\%Y-\%m-\%d \%H:\%M:\%S','u','v'{]}. This is the default csv format of
CampbellSci dataloggers. To disable this feature, you should parse the file with read\_csv using the kw: quoting=3.

\end{fulllineitems}

\index{read\_fileConfig() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_fileConfig}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_fileConfig}}{\emph{dlcfile}}{}
Reads metadata configuration file

WARNING! When defining the .config file note that by default columns that are enclosed between doublequotes
will appear without the doublequotes. So if your file is of the form :

``2013-04-05 00:00:00'', .345, .344, ...

Then the .dlc should have: variables = \{0:'\%Y-\%m-\%d \%H:\%M:\%S'\}. This is the default csv format of
CampbellSci dataloggers. To disable this feature, you should parse the file with read\_csv using the kw: quoting=3.

\end{fulllineitems}

\index{read\_site() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_site}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_site}}{\emph{sitefile}}{}
Reads .site configuration file, which holds siteConfig definitions
\begin{description}
\item[{The .site should have definitions as regular python syntax (in meters!):}] \leavevmode
measurement\_height  = 10
canopy\_height       = 5
displacement\_height = 3
roughness\_length    = 1.0

\item[{sitedile: str}] \leavevmode
path to .site file

\end{description}

\end{fulllineitems}

\index{timeSeries() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.timeSeries}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{timeSeries}}{\emph{flist}, \emph{datalogger}, \emph{parse\_dates=True}, \emph{verbose=False}, \emph{read\_data\_kw=\{\}}, \emph{parse\_dates\_kw=\{\}}, \emph{clean\_dates=True}, \emph{return\_units=True}, \emph{only\_named\_cols=True}}{}
Creates a micrometeorological time series from a file or list of files.

\end{fulllineitems}



\subsection{pymicra.methods module}
\label{pymicra:module-pymicra.methods}\label{pymicra:pymicra-methods-module}\index{pymicra.methods (module)}\index{binwrapper() (in module pymicra.methods)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.methods.binwrapper}\pysiglinewithargsret{\sphinxcode{pymicra.methods.}\sphinxbfcode{binwrapper}}{\emph{self}, \emph{clean\_index=True}, \emph{**kwargs}}{}
Method to return binned data from a dataframe using the function classbin

\end{fulllineitems}



\subsection{pymicra.physics module}
\label{pymicra:pymicra-physics-module}\label{pymicra:module-pymicra.physics}\index{pymicra.physics (module)}
Author: Tomas Chor

Module that contains physical functions for general use

TO DO LIST:
\begin{itemize}
\item {} 
ADD GENERAL SOLAR ZENITH CALCULATION

\item {} 
ADD FOOTPRINT CALCULATION?

\end{itemize}
\index{CtoK() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.CtoK}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{CtoK}}{\emph{T}}{}
Return temp in Kelvin given temp T in Celsius

\end{fulllineitems}

\index{R\_moistAir() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.R_moistAir}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{R\_moistAir}}{\emph{q}}{}
Calculates the gas constant for umid air from the specific humidity q

\end{fulllineitems}

\index{airDensity\_from\_theta() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.airDensity_from_theta}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{airDensity\_from\_theta}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace=True}, \emph{use\_means=False}, \emph{theta=None}, \emph{theta\_unit=None}}{}
Calculates moist air density using theta measurements

\end{fulllineitems}

\index{airDensity\_from\_theta\_v() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.airDensity_from_theta_v}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{airDensity\_from\_theta\_v}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace=True}, \emph{use\_means=False}}{}
Calculates moist air density using p = rho R\_dry T\_virtual

\end{fulllineitems}

\index{dewPointTemp() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.dewPointTemp}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{dewPointTemp}}{\emph{theta}, \emph{e}}{}
Calculates the dew point temperature.
theta has to be in Kelvin and e in kPa

\end{fulllineitems}

\index{dryAirDensity\_from\_p() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.dryAirDensity_from_p}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{dryAirDensity\_from\_p}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace=True}}{}
Calculates dry air density
NEEDS IMPROVEMENT REGARDING HANDLING OF UNITS

\end{fulllineitems}

\index{latent\_heat\_water() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.latent_heat_water}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{latent\_heat\_water}}{\emph{T}}{}
Calculates the latent heat of evaporation for water

Receives T in Kelvin and returns the latent heat in J/g

\end{fulllineitems}

\index{perfGas() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.perfGas}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{perfGas}}{\emph{p=None}, \emph{rho=None}, \emph{R=None}, \emph{T=None}, \emph{gas=None}}{}
Returns the only value that is not provided in the ideal gas law

P.S.: I'm using type to identify None objects because this way it works
againt pandas objects

\end{fulllineitems}

\index{ppxv2density() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.ppxv2density}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{ppxv2density}}{\emph{ser}, \emph{T}, \emph{p}, \emph{units}, \emph{solute=None}}{}
ser should be a series!
concentration in ser should be ppmv, which will be transformed to g/m3
p should be in kPa!

\end{fulllineitems}

\index{satWaterPressure() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.satWaterPressure}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{satWaterPressure}}{\emph{T}, \emph{unit='kelvin'}}{}
Returns the saturated water vapor pressure according eq (3.97) of Wallace and Hobbes, page 99.

e0, b, T1 and T2 are constants specific for water vapor

\end{fulllineitems}

\index{solarZenith() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.solarZenith}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{solarZenith}}{\emph{date}, \emph{lat=-3.13}, \emph{lon=-60.016667}, \emph{lon0=-63.0}, \emph{negative=False}, \emph{dr=None}}{}
Calculates the solar zenith angle at any given day

needs validation and needs to work without lon0

\end{fulllineitems}

\index{theta\_from\_theta\_s() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_from_theta_s}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_from\_theta\_s}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{return\_df=True}}{}
From Schotanus, Nieuwstadt, de Bruin; DOI 10.1007/BF00164332

theta\_s = theta (1 + 0.51 q) (1 - (vn/c)**2)**0.5
theta\_s \textasciitilde{} theta (1 + 0.51 q)

\end{fulllineitems}

\index{theta\_from\_theta\_v() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_from_theta_v}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_from\_theta\_v}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{return\_df=True}}{}
theta\_v \textasciitilde{} theta (1 + 0.61 q)

\end{fulllineitems}

\index{theta\_std\_from\_theta\_v\_fluc() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_std_from_theta_v_fluc}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_std\_from\_theta\_v\_fluc}}{\emph{1 + 0.61 q}}{}
\end{fulllineitems}



\subsection{pymicra.tests module}
\label{pymicra:pymicra-tests-module}\label{pymicra:module-pymicra.tests}\index{pymicra.tests (module)}\index{check\_RA() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_RA}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_RA}}{\emph{data}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{RAT\_vars=None}, \emph{RAT\_points=50}, \emph{RAT\_significance=0.05}}{}
Performs the Reverse Arrangement Test in each column of data

\end{fulllineitems}

\index{check\_limits() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_limits}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_limits}}{\emph{data}, \emph{tables}, \emph{max\_percent=1.0}, \emph{replace\_with='interpolation'}}{}
Checks dataframe for lower and upper limits. If found, they are substituted by 
the linear trend of the run. The number of faulty points is also checked for each
column against the maximum percentage of accepted faults max\_percent

\end{fulllineitems}

\index{check\_maxdif() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_maxdif}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_maxdif}}{\emph{data}, \emph{tables}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}}{}
Check the maximum and minimum differences between the fluctuations of a run.

\end{fulllineitems}

\index{check\_nans() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_nans}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_nans}}{\emph{data}, \emph{max\_percent=0.1}, \emph{replace\_with='interpolation'}}{}
Checks data for NaN values

\end{fulllineitems}

\index{check\_numlines() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_numlines}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_numlines}}{\emph{fname}, \emph{numlines=18000}, \emph{falseverbose=False}}{}
Checks length of file against a correct value.
Returns False is length is wrong and True if length is right
\begin{description}
\item[{fname: string}] \leavevmode
path of the file to check

\item[{numlines: int}] \leavevmode
correct number of lines that the file has to have

\end{description}

\end{fulllineitems}

\index{check\_replaced() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_replaced}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_replaced}}{\emph{replaced}, \emph{max\_count=180}}{}
Sums and checks if the number of replaced points is larger than the
maximum accepted

\end{fulllineitems}

\index{check\_spikes() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_spikes}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_spikes}}{\emph{data}, \emph{chunk\_size=`2min'}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{visualize=False}, \emph{vis\_col=1}, \emph{max\_consec\_spikes=3}, \emph{cut\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{replace\_with='interpolation'}, \emph{max\_percent=1.0}}{}
Applies spikes-check according to Vickers and Mahrt (1997)

\end{fulllineitems}

\index{check\_stationarity() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_stationarity}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_stationarity}}{\emph{data}, \emph{tables}, \emph{detrend=False}, \emph{detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{trend=True}, \emph{trend\_kw=\{`how': `movingmedian'}, \emph{`window': `1min'\}}}{}
Check difference between the maximum and minimum values of the run trend agaisnt an upper-limit.
This aims to flag nonstationary runs

\end{fulllineitems}

\index{check\_std() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_std}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_std}}{\emph{data}, \emph{tables}, \emph{detrend=False}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{chunk\_size=`2min'}, \emph{falseverbose=False}}{}
Checks dataframe for columns with too small of a standard deviation

\end{fulllineitems}



\subsection{pymicra.util module}
\label{pymicra:module-pymicra.util}\label{pymicra:pymicra-util-module}\index{pymicra.util (module)}\index{correctDrift() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.correctDrift}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{correctDrift}}{\emph{drifted}, \emph{correct\_drifted\_vars=None}, \emph{correct=None}, \emph{get\_fit=True}, \emph{write\_fit=True}, \emph{fit\_file='correctDrift\_linfit.params'}, \emph{apply\_fit=True}, \emph{show\_plot=False}, \emph{return\_plot=False}, \emph{units=\{\}}, \emph{return\_index=False}}{}
\end{fulllineitems}

\index{qcontrol() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.qcontrol}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{qcontrol}}{\emph{files}, \emph{datalogger\_config}, \emph{read\_files\_kw=\{`parse\_dates': False}, \emph{`only\_named\_cols': False}, \emph{`clean\_dates': False\}}, \emph{accepted\_nans\_percent=1.0}, \emph{accepted\_spikes\_percent=1.0}, \emph{accepted\_bound\_percent=1.0}, \emph{max\_replacement\_count=180}, \emph{file\_lines=None}, \emph{begin\_date=None}, \emph{end\_date=None}, \emph{nans\_test=True}, \emph{maxdif\_detrend=True}, \emph{maxdif\_detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{maxdif\_trend=True}, \emph{maxdif\_trend\_kw=\{`how': `movingmedian'}, \emph{`window': 600\}}, \emph{std\_detrend=True}, \emph{std\_detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{RAT\_detrend=True}, \emph{RAT\_detrend\_kw=\{`how': `linear'\}}, \emph{spikes\_detrend=True}, \emph{spikes\_detrend\_kw=\{`how': `linear'\}}, \emph{lower\_limits=\{\}}, \emph{upper\_limits=\{\}}, \emph{spikes\_test=True}, \emph{visualize\_spikes=False}, \emph{spikes\_vis\_col='u'}, \emph{spikes\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{replace\_with='interpolation'}, \emph{max\_consec\_spikes=3}, \emph{chunk\_size=1200}, \emph{std\_limits=\{\}}, \emph{dif\_limits=\{\}}, \emph{RAT=False}, \emph{RAT\_vars=None}, \emph{RAT\_points=50}, \emph{RAT\_significance=0.05}, \emph{trueverbose=False}, \emph{falseverbose=True}, \emph{falseshow=False}, \emph{trueshow=False}, \emph{trueshow\_vars=None}, \emph{outdir='quality\_controlled'}, \emph{summary\_file='qcontrol\_summary.csv'}, \emph{replaced\_report=None}, \emph{full\_report=None}}{}
Function that applies various tests quality control to a set of datafiles and re-writes
the successful files in another directory. A list of currently-applied tests is found 
below in order of application. The only test available by default is the spikes test.
All others depend on their respective keywords.
\begin{description}
\item[{date check:}] \leavevmode
files outside a date\_range are left out (end\_date and begin\_date keywords)

\item[{lines test:}] \leavevmode
checks each file to see if they have a certain number of lines. Files with a different number of lines
fail this test. Active this test by passing the file\_lines keyword.

\end{description}
\begin{description}
\item[{NaNs test:}] \leavevmode
checks for any NaN values. NaNs are replaced with interpolation or linear trend. If the percentage
of NaNs is greater than accepted\_nans\_percent, run is discarded. Activate it by passing nans\_test=True.

\item[{boundaries test:}] \leavevmode
runs with values in any column lower than a pre-determined lower limit or higher
than a upper limits are left out. Activate it by passing a lower\_limits or upper\_limits keyword.

\item[{spikes test:}] \leavevmode
runs with more than a certain percetage of spikes are left out. 
Activate it by passing a spikes\_test keyword. Adjust the test with the spikes\_func
visualize\_spikes, spikes\_vis\_col, max\_consec\_spikes, accepted\_spikes\_percent and chunk\_size keywords.

\item[{replacement count test:}] \leavevmode
checks the total amount of points that were replaced (including NaN, boundaries and spikes test)
against the max\_replacement\_count keyword. Fails if any columns has more replacements than that.

\item[{standard deviation (STD) check:}] \leavevmode
runs with a standard deviation lower than a pre-determined value (generally close to the
sensor precision) are left out.
Activate it by passing a std\_limits keyword.

\item[{maximum difference test:}] \leavevmode
runs whose trend have a maximum difference greater than a certain value are left out.
This excludes non-stationary runs. Activate it by passing a dif\_limits keyword.

\item[{reverse arrangement test (RAT):}] \leavevmode
runs that fail the reverse arrangement test for any variable are left out.
Activate it by passing a RAT keyword.

\end{description}

\end{fulllineitems}

\index{separateFiles() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.separateFiles}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{separateFiles}}{\emph{files}, \emph{dlconfig}, \emph{outformat='out\_\%Y-\%m-\%d\_\%H:\%M.csv'}, \emph{outdir='`}, \emph{verbose=False}, \emph{firstflag='.first'}, \emph{lastflag='.last'}, \emph{save\_ram=False}, \emph{frequency=`30min'}, \emph{quoting=0}, \emph{use\_edges=False}}{}
Separates files into (default) 30-minute smaller files. Useful for output files such
as the ones by Campbell Sci, that can have days of data in one single file.

\end{fulllineitems}



\subsection{Module contents}
\label{pymicra:module-pymicra}\label{pymicra:module-contents}\index{pymicra (module)}

\subsubsection{Pymicra - Python Micrometeorology Analysis tool}
\label{pymicra:pymicra-python-micrometeorology-analysis-tool}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Tomas Chor

\item[{Date of start}] \leavevmode
2015-08-15

\end{description}\end{quote}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pymicra}}, \pageref{pymicra:module-pymicra}
\item {\texttt{pymicra.constants}}, \pageref{pymicra:module-pymicra.constants}
\item {\texttt{pymicra.core}}, \pageref{pymicra:module-pymicra.core}
\item {\texttt{pymicra.data}}, \pageref{pymicra:module-pymicra.data}
\item {\texttt{pymicra.decorators}}, \pageref{pymicra:module-pymicra.decorators}
\item {\texttt{pymicra.io}}, \pageref{pymicra:module-pymicra.io}
\item {\texttt{pymicra.methods}}, \pageref{pymicra:module-pymicra.methods}
\item {\texttt{pymicra.physics}}, \pageref{pymicra:module-pymicra.physics}
\item {\texttt{pymicra.tests}}, \pageref{pymicra:module-pymicra.tests}
\item {\texttt{pymicra.util}}, \pageref{pymicra:module-pymicra.util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
