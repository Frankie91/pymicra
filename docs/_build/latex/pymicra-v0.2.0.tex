% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[a4paper,10pt,oneside]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{Pymicra Documentation}
\date{2016-07-22}
\release{0.2.0}
\author{Tom√°s Chor}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{starry.jpg}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Pymicra is a Python package designed to make it easier to work with
micrometeorological datasets. It is aimed at improving the productivity and
allowing us to focus on the micrometeorological, rather than programming
issues.

Please check out the \href{https://github.com/tomchor/pymicra}{Github page} and the
\href{http://tomchor.github.io/pymicra/}{documentation}.

Here's a quick (incomplete!) list of what Pymicra does:
\begin{itemize}
\item {} 
Reading, separating and understanding micrometeorological data in
virtually any column-separated ASCII format (thanks to pandas).

\item {} 
Quality control methods (max and min values check, spikes,
reverse-arrangement test and etc..

\item {} 
Rotation of coordinates (2D).

\item {} 
Detrending of data in the most common ways (block averages, moving
averages and polynomial detrending).

\item {} 
Correction of sensor drift.

\item {} 
Automatic calculation of most auxiliary variables based on
measurements (air density, dry air density, etc.).

\item {} 
Calculation of spectra and cross-spectra.

\item {} 
Calculation fluxes and characteristic scales with or without WPL correction.

\item {} 
Provide common constants generally used in atmospheric sciences.

\item {} 
Plus all native features of Pandas (interpolation, resampling,
grouping, statistical tests, slicing, handling of missing data and
etc.).

\end{itemize}

The package is extensively (almost entirely) based on Pandas, mostly the
\sphinxcode{pandas.DataFrame} class. We use Pint for units control and (generally) Numpy
or Scipy for some numerical functions not contained in Pandas.


\chapter{Introduction}
\label{intro:introduction}\label{intro:pymicra-a-python-tool-for-micrometeorological-analyses}\label{intro:scipy}\label{intro::doc}
Pymicra is a Python package that was created to condense many of the knowledge
of the micrometeorological community in one single fast-to-implement software
that is freely available to anyone. Because of that, I made an effort to
include a detailed docstring along with every function and class. By doing that
I hope to have made every function, class etc. pretty self-explanatory, both
within the auto-generated docs (thanks to Sphinx) and by importing the package
and running \sphinxcode{help(pymicra.timeSeries)}, for example.

Since Pymicra is meant to be a community package, improvements, suggestions of
improvement, and any kind of feedback are highly appreciated. The code is
available at \href{https://github.com/tomchor/pymicra}{its github page} and any contact can be made through there
(possibly creating an issue) or via e-mail.

In order for the user to program fast and effectively (and to reduce the time it
takes me to write its code), Pymicra was written on top of the
\href{http://pandas.pydata.org/}{Pandas package}, so that it is faster to run
the same code using Pymicra than it is running pure Python. As a consequence,
Pymicra makes extensive use of Pandas' DataFrame class, which is a very useful
2-D data structure optimized for performance and for timestamp-indexed data.

It is possible to use Pymicra without having to be familiar with Pandas, but
because Pymicra depends on Pandas, I suggest at the very least that the user
take a quick look at a Pandas tutorial
\href{http://pandas.pydata.org/pandas-docs/stable/10min.html}{this one for example}
so that one can be familiarized with the many functionalities that
Pandas offers in order to take full advantage of Pymicra.


\chapter{Installation}
\label{install:installation}\label{install::doc}
\begin{notice}{warning}{Warning:}
The commands written here assume you are running a Ubuntu-based distribution of
Linux. Although the basic steps should be similar for all Linux distributions, you
should adapt the specific commands to your system in case you are using any other OS.
\end{notice}

Most of the required packages already come with python. However, packages that
generally have to be manually installed beforehand are:
\begin{itemize}
\item {} 
Pandas (recommended 0.17.1)

\item {} 
Pint (0.7.2)

\item {} 
Numpy

\item {} 
Scipy

\item {} 
setuptools (for installation only)

\end{itemize}

In order to install Pymicra the \sphinxcode{setuptools} Python package should be
installed. If you don't have it installed already you can install it with
\sphinxcode{sudo apt install python-setuptools} or \sphinxcode{sudo pip install setuptools}.

Download the package from the \href{https://github.com/tomchor/pymicra}{Github repo} and unpack it somewhere. Then open a
terminal and move to the directory created, whose name should be \sphinxcode{pymicra}.
Then run \sphinxcode{sudo python setup.py install}. This should be enough to install the
package.

This should successfully install Pymicra. The only
requirements are Pandas and Pint. Version 0.17 of Pandas is suggested, but it
should work fine will any distribution from 0.13 up to 0.17.1 (0.18 is not
supported because of changed in the rolling functions API).

Although fairly general, I have tested the setup program on a limited number of
computers so far, so it is possible that an error occurs depending on the
version of some auxiliary packages you have installed. If that happens and the
installation fails for some reason, please contact me through email or creating
a github issue detailing your problem and I will improve the setup file.

In case errors arise, please try to manually install versions 1.11.0 of Numpy
and 0.17.0 of Scipy and then running \sphinxcode{sudo python setup.py install} again. If
still installation fails, please create a \href{https://github.com/tomchor/pymicra/issues}{Github issue} stating your OS, Python
version and any relevant information.

To remove Pymicra, the easiest way is to use pip
(\sphinxcode{sudo apt-get install python-pip}) with the command
\sphinxcode{sudo pip uninstall pymicra}.


\chapter{Getting started}
\label{tutorial:getting-started}\label{tutorial::doc}
This ``Getting started'' tutorial is a brief introduction to Pymicra. This is in
no way supposed to be a complete representation of everything that can be done
with Pymicra.


\section{Notation}
\label{tutorial:notation}
Pymicra uses a specific notation to name each one of its columns. This notation
is extremely important, because it is by these labels that Pymicra knows which
variable is in each column. You can check the default notation with

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pymicra}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{pymicra}\PYG{o}{.}\PYG{n}{notation}\PYG{p}{)}
\end{Verbatim}

On the left you see the full name of the variables (which corresponds to a notation namespace) and on the right
we see the default notation for that variable.

You can change Pymicra's notation at any time by altering the attributes of
\sphinxcode{pymicra.notation}.

\begin{notice}{note}{Todo}

Extend this section with some examples
\end{notice}


\section{Reading datafiles}
\label{tutorial:reading-datafiles}
The easiest way to read data files is using the \sphinxcode{timeSeries} function with a
\sphinxcode{fileConfig} object such as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{config} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{fileConfig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{example.config}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{timeSeries}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1H\PYGZus{}20130504.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{config}\PYG{p}{,} \PYG{n}{parse\PYGZus{}dates}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

First,
let's explain what the \sphinxcode{fileConfig} class does. This class holds
most of the configurations inherent to the datalogger that actually influence
the file output (such as columns separator), which variable is in each column,
variables units, frequency, file headers, etc..


\subsection{Creating file configurations}
\label{tutorial:creating-file-configurations}
You can create a \sphinxcode{fileConfig} object manually by passing each of
these informations as a keyword to the \sphinxcode{fileConfig} function, but
the easiest method is to create a texttt\{.dlc\} file (meaning datalogger
configuration), store it somewhere and create a \sphinxcode{fileConfig} object
by reading it every time you work with files with that same configuration.

Consider the example texttt\{.dlc\} file below, which will be explained next.

lstinputlisting\{ex\_itaipu.dlc\}

First of all, every .dlc file is writen in Python syntax, so it has to be able
to actually be run on python. The description is optional and the
texttt\{first\_time\_skip\} and texttt\{date\_connector\} keywords are generally
not necessary, so you'll rarely have to use them. They can be omitted from the
file.

The most important keyword is texttt\{varNames\}. Since Pymicra works with labels for its
data, its best if all the names of the variables are properly writen, preferably
following the default Pymicra notation. Let look at how to write parts of the
timestamp first.

The columns that contain parts of the date have to have their name matching
Python's
href\{\url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}\}\{date
format string directive\}. This is useful in case you want to index your data by
timestamp, which is a huge advantage in some cases (check out what Pandas can do
with
href\{\url{http://pandas.pydata.org/pandas-docs/stable/timeseries.html}\}\{timestamp-indexed
data\}). If you don't wish to work with timestamps and want to work only by line
number in each file, you can ignore there columns.

As for the physical quantities, it is strongly advised to follow Pymicra's
notation, which is described in Pymicra's README.md file and explained in
Chapter ref\{chap:notation\}. In the above example, which follows the Pymicra
notation, u, v and w are the three wind components, texttt\{theta\_v\} stands for
the virtual temperature, and texttt\{mrho\_h2o\} stands for the molar density of
H2O. If it were the mass density the name would have been texttt\{rho\_h2o\},
according to the notation.

The texttt\{date\_cols\}

The texttt\{frequency\}, in Hertz, is the frequency of the data collection.
Useful mostly when taking the spectrum or cospectrum.

The texttt\{columns\} separator is what separates one column from the other.
Generaly it is one character, such as a comma or a whitespace. A special case
happens is if the columns are separated by whitespaces of varying length. In
that case just put ``whitespace''.

The keyword texttt\{header\_lines\} is an int, or list of ints saying which rows
are headers, starting from zero. So if the first two rows of the file are a
header, the texttt\{header\_lines\} in this case should be texttt\{{[}0, 1{]}\}.

The \{filename\_format\}

The tt\{date\_connector\}

The tt\{first\_time\_skip\}

With this file ready, it is easy to read any datafile. Consider the example
below

EXAMPLE

In it we passed the path of a file to read and the tt\{fileConfig\} object
containing the configuration of the file. The function tt\{timeSeries\} reads the
file according to the options provided and returns a DataFrame that is put into
the tt\{data\} variable. Printing tt\{data\}, in this case, would print the
following on screen.

DATA PRINT

Notice that every variable defined in our datalogger configuration file appears in the
data variable.


\section{Viewing and manipulating data}
\label{tutorial:viewing-and-manipulating-data}
To view and manipulate data you have to follow Pandas's DataFrame rules. For
that we suggest that the user visit a Pandas tutorial. However, I'll explain
some main ideas here for the sake of completeness.


\section{Converting between different units}
\label{tutorial:converting-between-different-units}
Pymicra has some handy functions that convert between units using Pint.


\section{Extracting fluxes}
\label{tutorial:extracting-fluxes}
Although you can extract the fluxes manually either using the DataFrame or extracting
the Numpy arrays, Pymicra has a couple of functions that come in handy.


\section{Obtaining the spectra}
\label{tutorial:obtaining-the-spectra}
Using Numpy's fast Fourier transform implementation, Pymicra is also able to extract
spectra, cospectra and quadratures.


\chapter{Pymicra's auto-generated docs}
\label{pymicra:pymicra-s-auto-generated-docs}\label{pymicra::doc}

\section{Subpackages}
\label{pymicra:subpackages}

\section{Submodules}
\label{pymicra:submodules}

\section{pymicra.constants module}
\label{pymicra:module-pymicra.constants}\label{pymicra:pymicra-constants-module}\index{pymicra.constants (module)}
Defines some useful constants


\section{pymicra.core module}
\label{pymicra:module-pymicra.core}\label{pymicra:pymicra-core-module}\index{pymicra.core (module)}\index{Notation (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{Notation}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This creates an object that holds the default notation for pymicra.
Example of usage:

notation = notation()

fluctuations\_of\_co2\_conc = notation.concentration \% notation.fluctuations \% notation.co2

You should be careful with the order. The last argument should not have any `\%' symbols
or you'll get a ``TypeError: not all arguments converted during string formatting'' message.
\index{build() (pymicra.core.Notation method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.build}\pysiglinewithargsret{\sphinxbfcode{build}}{}{}
This useful method builds the full notation based on the base notation

\end{fulllineitems}

\index{concentration (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.concentration}\pysigline{\sphinxbfcode{concentration}\sphinxstrong{ = `conc\_\%s'}}
\end{fulllineitems}

\index{cospectrum (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.cospectrum}\pysigline{\sphinxbfcode{cospectrum}\sphinxstrong{ = `Co\_\%s\_\%s'}}
\end{fulllineitems}

\index{cross\_spectrum (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.cross_spectrum}\pysigline{\sphinxbfcode{cross\_spectrum}\sphinxstrong{ = `X\_\%s\_\%s'}}
\end{fulllineitems}

\index{density (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.density}\pysigline{\sphinxbfcode{density}\sphinxstrong{ = `rho\_\%s'}}
\end{fulllineitems}

\index{fluctuations (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.fluctuations}\pysigline{\sphinxbfcode{fluctuations}\sphinxstrong{ = ``\%s'''}}
\end{fulllineitems}

\index{flux\_of (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.flux_of}\pysigline{\sphinxbfcode{flux\_of}\sphinxstrong{ = `F\_\%s'}}
\end{fulllineitems}

\index{mass\_concentration (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mass_concentration}\pysigline{\sphinxbfcode{mass\_concentration}\sphinxstrong{ = `conc\_\%s'}}
\end{fulllineitems}

\index{mass\_density (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mass_density}\pysigline{\sphinxbfcode{mass\_density}\sphinxstrong{ = `rho\_\%s'}}
\end{fulllineitems}

\index{mass\_mixing\_ratio (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mass_mixing_ratio}\pysigline{\sphinxbfcode{mass\_mixing\_ratio}\sphinxstrong{ = `r\_\%s'}}
\end{fulllineitems}

\index{mean (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mean}\pysigline{\sphinxbfcode{mean}\sphinxstrong{ = `\%s\_mean'}}
\end{fulllineitems}

\index{mixing\_ratio (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.mixing_ratio}\pysigline{\sphinxbfcode{mixing\_ratio}\sphinxstrong{ = `r\_\%s'}}
\end{fulllineitems}

\index{molar\_concentration (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.molar_concentration}\pysigline{\sphinxbfcode{molar\_concentration}\sphinxstrong{ = `mconc\_\%s'}}
\end{fulllineitems}

\index{molar\_density (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.molar_density}\pysigline{\sphinxbfcode{molar\_density}\sphinxstrong{ = `mrho\_\%s'}}
\end{fulllineitems}

\index{molar\_mixing\_ratio (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.molar_mixing_ratio}\pysigline{\sphinxbfcode{molar\_mixing\_ratio}\sphinxstrong{ = `mr\_\%s'}}
\end{fulllineitems}

\index{quadrature (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.quadrature}\pysigline{\sphinxbfcode{quadrature}\sphinxstrong{ = `Qu\_\%s\_\%s'}}
\end{fulllineitems}

\index{spectrum (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.spectrum}\pysigline{\sphinxbfcode{spectrum}\sphinxstrong{ = `Sp\_\%s'}}
\end{fulllineitems}

\index{star (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.star}\pysigline{\sphinxbfcode{star}\sphinxstrong{ = `\%s\_star'}}
\end{fulllineitems}

\index{std (pymicra.core.Notation attribute)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.Notation.std}\pysigline{\sphinxbfcode{std}\sphinxstrong{ = `\%s\_std'}}
\end{fulllineitems}


\end{fulllineitems}

\index{dataloggerConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.dataloggerConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{dataloggerConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This class defines a specific configuration of a datalogger output file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{from\_file}} (\emph{\texttt{str}}) -- path of .dlc file (datalogger configuration file) to read from. This will ignore all other
keywords.

\item {} 
\textbf{\texttt{varNames}} (\emph{\texttt{list of strings or dict}}) -- If a list: should be a list of strings with the names of the variables. If the variable
is part if the date, then it should be provided as a datetime directive,
so if the columns is only the year, its name must be \sphinxtitleref{\%Y} and so forth. While
if it is the date in YYYY/MM/DD format, it should be \sphinxtitleref{\%Y/\%m/\%d}. For more info
see \url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}
If a dict: the keys should be the numbers of the columns and the items should follow
the rules for a list.

\item {} 
\textbf{\texttt{date\_cols}} (\emph{\texttt{list of ints}}) -- should be indexes of the subset of varNames that corresponds to the variables that compose
the timestamp. If it is not provided the program will try to guess by getting
all variable names that have a percentage sign (\%).

\item {} 
\textbf{\texttt{date\_connector}} (\emph{\texttt{string}}) -- generally not really necessary. It is used to join and then parse the date\_cols.

\item {} 
\textbf{\texttt{columns\_separator}} (\emph{\texttt{string}}) -- used to assemble the date. Should only be used if the default char creates conflict. If
the file is tabular-separated then this should be ``whitespace''.

\item {} 
\textbf{\texttt{header\_lines}} (\emph{\texttt{int}}) -- up to which line of the file is a header. See pandas.read\_csv header option.

\item {} 
\textbf{\texttt{first\_time\_skip}} (\emph{\texttt{int}}) -- how many units of frequency the first line of the file is offset (generally zero).

\item {} 
\textbf{\texttt{filename\_format}} (\emph{\texttt{string}}) -- 
tells the format of the file with the standard notation for date and time and with variable
parts as ''?''. E.g. if the files are 56\_20150101.csv, 57\_20150102.csv etc filename\_format should be:
\begin{quote}

??\_\%Y\%m\%d.csv
\end{quote}

this is useful primarily for the quality control feature.


\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dictionary}}) -- very important: a dictionary whose keys are the columns of the file and whose items are
the units in which they appear.

\item {} 
\textbf{\texttt{description}} (\emph{\texttt{string}}) -- brief description of the datalogger configuration file.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fileConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{fileConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

This class defines a specific configuration of a data file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{from\_file}} (\emph{\texttt{str}}) -- path of .cfg file (configuration file) to read from. This will ignore all other
keywords.

\item {} 
\textbf{\texttt{variables}} (\emph{\texttt{list of strings or dict}}) -- If a list: should be a list of strings with the names of the variables. If the variable
is part if the date, then it should be provided as a datetime directive,
so if the columns is only the year, its name must be \sphinxtitleref{\%Y} and so forth. While
if it is the date in YYYY/MM/DD format, it should be \sphinxtitleref{\%Y/\%m/\%d}. For more info
see \url{https://docs.python.org/2/library/datetime.html\#strftime-and-strptime-behavior}
If a dict: the keys should be the numbers of the columns and the items should follow
the rules for a list.

\item {} 
\textbf{\texttt{date\_cols}} (\emph{\texttt{list of ints}}) -- should be indexes of the subset of varNames that corresponds to the variables that compose
the timestamp. If it is not provided the program will try to guess by getting
all variable names that have a percentage sign (\%).

\item {} 
\textbf{\texttt{date\_connector}} (\emph{\texttt{string}}) -- generally not really necessary. It is used to join and then parse the date\_cols.

\item {} 
\textbf{\texttt{columns\_separator}} (\emph{\texttt{string}}) -- used to assemble the date. If the file is tabular-separated then this should be ``whitespace''.

\item {} 
\textbf{\texttt{header\_lines}} (\emph{\texttt{int or list}}) -- up to which line of the file is a header. See pandas.read\_csv header option.

\item {} 
\textbf{\texttt{filename\_format}} (\emph{\texttt{string}}) -- 
tells the format of the file with the standard notation for date and time and with variable
parts as ''?''. E.g. if the files are 56\_20150101.csv, 57\_20150102.csv etc filename\_format should be:
\begin{quote}

??\_\%Y\%m\%d.csv
\end{quote}

this is useful primarily for the quality control feature.


\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dictionary}}) -- very important: a dictionary whose keys are the columns of the file and whose items are
the units in which they appear.

\item {} 
\textbf{\texttt{description}} (\emph{\texttt{string}}) -- brief description of the datalogger configuration file.

\item {} 
\textbf{\texttt{varNames}} (\emph{\texttt{DEPRECATED}}) -- use variables now.

\end{itemize}

\end{description}\end{quote}
\index{check\_consistency() (pymicra.core.fileConfig method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig.check_consistency}\pysiglinewithargsret{\sphinxbfcode{check\_consistency}}{}{}
Checks consistency of fileConfig
Currently only checks every key of self.units dictionary agaisnt values of variables dict.

\end{fulllineitems}

\index{get\_date\_cols() (pymicra.core.fileConfig method)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.fileConfig.get_date_cols}\pysiglinewithargsret{\sphinxbfcode{get\_date\_cols}}{}{}
Guesses what are the columns that contain the dates by searching
for percentage signs in them

\end{fulllineitems}


\end{fulllineitems}

\index{myData (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.myData}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{myData}}{\emph{df}, \emph{dic}}{}
Bases: \sphinxcode{object}

Attempt to create a myData object

\end{fulllineitems}

\index{siteConfig (class in pymicra.core)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.core.siteConfig}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{pymicra.core.}\sphinxbfcode{siteConfig}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

Keeper of the configurations and constants of an experiment. (such as height of instruments,
location, canopy height and etc)

\end{fulllineitems}



\section{pymicra.data module}
\label{pymicra:pymicra-data-module}\label{pymicra:module-pymicra.data}\index{pymicra.data (module)}\index{bulkCorr() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.bulkCorr}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{bulkCorr}}{\emph{data}}{}
Bulk correlation coefficient according to
Cancelli, Dias, Chamecki. Dimensionless criteria for the production of...
doi:10.1029/2012WR012127
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- a two-columns dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{crossSpectra() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.crossSpectra}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{crossSpectra}}{\emph{data}, \emph{frequency=10}, \emph{notation=None}, \emph{anti\_aliasing=True}}{}
Calculates the spectrum for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame or pandas.Series}}) -- dataframe with one (will return the spectrum) or two (will return to cross-spectrum) columns

\item {} 
\textbf{\texttt{frequency}} (\emph{\texttt{float}}) -- frequency of measurement of signal to pass to numpy.fft.rfftfreq

\item {} 
\textbf{\texttt{anti\_aliasing}} (\emph{\texttt{bool}}) -- whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{notation object}}) -- notation to be used

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{spectrum} -- whose column is the spectrum or coespectrum of the input dataframe

\item[{Return type}] \leavevmode
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{detrend() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.detrend}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{detrend}}{\emph{*args}, \emph{**kwargs}}{}
Returns the detrended fluctuations of a given dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame, pandas.Series}}) -- dataset to be detrended

\item {} 
\textbf{\texttt{how}} (\emph{\texttt{string}}) -- how of average to apply. Currently \{`movingmean', `movingmedian', `block', `linear', `poly'\}.

\item {} 
\textbf{\texttt{rule}} (\emph{\texttt{pandas offset string}}) -- the blocks for which the trends should be calculated in the block and linear type

\item {} 
\textbf{\texttt{window}} (\emph{\texttt{pandas date offset string or int}}) -- if moving mean/median is chosen, this tells us the window size to pass to pandas. If int,
this is the number of points used in the window. If string we will to guess the number of
points from the index.
Small windows (equivalent to 1min approx) work better when using rollingmedian.

\item {} 
\textbf{\texttt{block\_func}} (\emph{\texttt{str, function}}) -- how to resample in block type. Default is mean but it can be any numpy function
that returns a float. E.g, median.

\item {} 
\textbf{\texttt{degree}} (\emph{\texttt{int}}) -- degree of polynomial fit (only if how=='linear' or how=='polynomial')

\item {} 
\textbf{\texttt{Returns}} -- out: pandas.DataFrame or pandas.Series

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse\_arrangement() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.reverse_arrangement}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{reverse\_arrangement}}{\emph{array}, \emph{points\_number=None}, \emph{alpha=0.05}, \emph{verbose=False}}{}
Performs the reverse arrangement test
according to Bendat and Piersol - Random Data - 4th edition, page 96
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} (\emph{\texttt{np.array, list, tuple, generator}}) -- array which to test for the reverse arrangement test

\item {} 
\textbf{\texttt{points\_number}} (\emph{\texttt{integer}}) -- number of chunks to consider to the test. Maximum is the length of the array.
If it is less, then the number of points will be reduced by application of a mean

\item {} 
\textbf{\texttt{alpha}} (\emph{\texttt{float}}) -- Significance level for which to apply the test

\item {} 
\textbf{\texttt{This fuction approximates table A.6 from Bendat\&Piersol as a normal distribution.}} (\emph{\texttt{WARNING!}}) -- 

\item {} 
\textbf{\texttt{may no be true, since they do not express which distribution they use to construct}} (\emph{\texttt{This}}) -- 

\item {} 
\textbf{\texttt{table. However, in the range 9\textless{}N\textless{}101, this approximation is as good as 5\% at N=10}} (\emph{\texttt{their}}) -- 

\item {} 
\textbf{\texttt{0.1\% at N=100.}} (\emph{\texttt{and}}) -- 

\item {} 
\textbf{\texttt{not adapted for dataframes}} (\emph{\texttt{Still}}) -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{rotate2D() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.rotate2D}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{rotate2D}}{\emph{data}, \emph{notation=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas DataFrame}}) -- the dataFrame to be rotated

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{notation object}}) -- a notation object to know which are the wind variables

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{spectra() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.spectra}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{spectra}}{\emph{*args}, \emph{**kwargs}}{}
Calculates the cross-spectra for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame or pandas.Series}}) -- dataframe with more than one columns

\item {} 
\textbf{\texttt{frequency}} (\emph{\texttt{float}}) -- frequency of measurement of signal to pass to numpy.fft.rfftfreq

\item {} 
\textbf{\texttt{anti\_aliasing}} (\emph{\texttt{bool}}) -- whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{spectra} -- whose column is the spectrum or coespectrum of the input dataframe

\item[{Return type}] \leavevmode
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{spectrum() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.spectrum}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{spectrum}}{\emph{data}, \emph{frequency=10}, \emph{anti\_aliasing=False}, \emph{outname=None}}{}
Calculates the spectrum for a set of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataframe with one (will return the spectrum) or two (will return to cross-spectrum) columns

\item {} 
\textbf{\texttt{frequency}} (\emph{\texttt{float}}) -- frequency of measurement of signal to pass to numpy.fft.rfftfreq

\item {} 
\textbf{\texttt{anti\_aliasing}} (\emph{\texttt{bool}}) -- whether or not to apply anti-aliasing according to Gobbi, Chamecki \& Dias, 2006 (doi:10.1029/2005WR004374)

\item {} 
\textbf{\texttt{outname}} (\emph{\texttt{str}}) -- name of the output column

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{spectrum} -- whose column is the spectrum or coespectrum of the input dataframe

\item[{Return type}] \leavevmode
dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{trend() (in module pymicra.data)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.data.trend}\pysiglinewithargsret{\sphinxcode{pymicra.data.}\sphinxbfcode{trend}}{\emph{*args}, \emph{**kwargs}}{}
Wrapper to return the trend given data. Can be achieved using a moving avg, block avg or polynomial fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame or pandas.Series}}) -- the data whose trend wee seek.

\item {} 
\textbf{\texttt{how}} (\emph{\texttt{string}}) -- how of average to apply. Currently \{`movingmean', `movingmedian', `block', `linear'\}.

\item {} 
\textbf{\texttt{rule}} (\emph{\texttt{string}}) -- pandas offset string to define the block in the block average. Default is ``10min''.

\item {} 
\textbf{\texttt{window}} (\emph{\texttt{pandas date offset string or int}}) -- if moving mean/median is chosen, this tells us the window size to pass to pandas. If int,
this is the number of points used in the window. If string we will to guess the number of
points from the index.
Small windows (equivalent to 1min approx) work better when using rollingmedian.

\item {} 
\textbf{\texttt{block\_func}} (\emph{\texttt{str, function}}) -- how to resample in block type. Default is mean but it can be any numpy function
that returns a float. E.g, median.

\item {} 
\textbf{\texttt{degree}} (\emph{\texttt{int}}) -- degree of polynomial fit (only if how=='linear' or how=='polynomial')

\item {} 
\textbf{\texttt{Returns}} -- out: pandas.DataFrame or pandas.Series

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.decorators module}
\label{pymicra:pymicra-decorators-module}\label{pymicra:module-pymicra.decorators}\index{pymicra.decorators (module)}\index{autoassign() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.autoassign}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{autoassign}}{\emph{function}}{{ $\rightarrow$ method}}
autoassign({\color{red}\bfseries{}*}argnames) -\textgreater{} decorator
autoassign(exclude=argnames) -\textgreater{} decorator

allow a method to assign (some of) its arguments as attributes of
`self' automatically.  E.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{Foo}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nd}{@autoassign}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{foo}\PYG{p}{,} \PYG{n}{bar}\PYG{p}{)}\PYG{p}{:} \PYG{k}{pass}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{breakfast} \PYG{o}{=} \PYG{n}{Foo}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eggs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{breakfast}\PYG{o}{.}\PYG{n}{foo}\PYG{p}{,} \PYG{n}{breakfast}\PYG{o}{.}\PYG{n}{bar}
\PYG{g+go}{(\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}eggs\PYGZsq{})}
\end{Verbatim}

To restrict autoassignment to `bar' and `baz', write:
\begin{quote}

@autoassign(`bar', `baz')
def method(self, foo, bar, baz): ...
\end{quote}

To prevent `foo' and `baz' from being autoassigned, use:
\begin{quote}

@autoassign(exclude=(`foo', `baz'))
def method(self, foo, bar, baz): ...
\end{quote}

\end{fulllineitems}

\index{pdgeneral() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral}}{\emph{convert\_out=True}}{}
\end{fulllineitems}

\index{pdgeneral\_in() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral_in}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral\_in}}{\emph{func}}{}
\end{fulllineitems}

\index{pdgeneral\_io() (in module pymicra.decorators)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.decorators.pdgeneral_io}\pysiglinewithargsret{\sphinxcode{pymicra.decorators.}\sphinxbfcode{pdgeneral\_io}}{\emph{func}}{}
If the input is a series transform it to a dtaframe then transform the output from dataframe
back into a series. If the input is a series and the output is a one-element series, transform it to a float.

Currently the output functionality works only when the output is one variable, not an array
of elements.

\end{fulllineitems}



\section{pymicra.io module}
\label{pymicra:module-pymicra.io}\label{pymicra:pymicra-io-module}\index{pymicra.io (module)}
Author: Tomas Chor
Date: 2015-08-07
-------------------------
\index{dataset() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.dataset}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{dataset}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{readDataFile() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readDataFile}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readDataFile}}{\emph{fname}, \emph{variables=None}, \emph{only\_named\_cols=True}, \emph{**kwargs}}{}
Reads one datafile using pandas.read\_csv()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{variables}} (\emph{\texttt{list or dict}}) -- keys are columns and values are names of variable

\item {} 
\textbf{\texttt{only\_named\_columns}} (\emph{\texttt{bool}}) -- if True, don't read columns that don't appear on variables' keys

\item {} 
\textbf{\texttt{kwargs}} (\emph{\texttt{dict}}) -- dictionary with kwargs of pandas' read\_csv function
see \url{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read\_csv.html} for more detail

\item {} 
\textbf{\texttt{variables}} -- list or dictionary containing the names of each variable in the file (if dict, the keys must be ints)

\end{itemize}

\item[{Returns}] \leavevmode
pandas.DataFrame object

\item[{Return type}] \leavevmode
dataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{readDataFiles() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readDataFiles}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readDataFiles}}{\emph{flist}, \emph{verbose=0}, \emph{**kwargs}}{}
Reads data from a list of files by calling readDataFile individually for each entry
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{flist}} (\emph{\texttt{sequence of strings}}) -- files to be parsed

\item {} 
\textbf{\texttt{verbose}} (\emph{\texttt{bool}}) -- whether to print

\item {} 
\textbf{\texttt{**kwargs}} -- readDataFile kwargs

\end{itemize}

\item[{Returns}] \leavevmode
data

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{readUnitsCsv() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.readUnitsCsv}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{readUnitsCsv}}{\emph{filename}, \emph{**kwargs}}{}
Reads a csv file in which the first line is the name of the variables
and the second line contains the units
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} (\emph{\texttt{string}}) -- path of the csv file to read

\item {} 
\textbf{\texttt{**kwargs}} -- to be passed to pandas.read\_csv

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{df} (\emph{pandas.DataFrame}) -- dataframe with the data

\item {} 
\textbf{unitsdic} (\emph{dictionary}) -- dictionary with the variable names as keys and the units as values

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{read\_dlc() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_dlc}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_dlc}}{\emph{dlcfile}}{}
Reads datalogger configuration file

WARNING! When defining the .dlc note that by default columns that are enclosed between doublequotes
will appear without the doublequotes. So if your file is of the form :

``2013-04-05 00:00:00'', .345, .344, ...

Then the .dlc should have: varNames={[}'\%Y-\%m-\%d \%H:\%M:\%S','u','v'{]}. This is the default csv format of
CampbellSci dataloggers. To disable this feature, you should parse the file with read\_csv using the kw: quoting=3.

\end{fulllineitems}

\index{read\_fileConfig() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_fileConfig}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_fileConfig}}{\emph{dlcfile}}{}
Reads metadata configuration file

WARNING! When defining the .config file note that by default columns that are enclosed between doublequotes
will appear without the doublequotes. So if your file is of the form :

``2013-04-05 00:00:00'', .345, .344, ...

Then the .dlc should have: variables = \{0:'\%Y-\%m-\%d \%H:\%M:\%S'\}. This is the default csv format of
CampbellSci dataloggers. To disable this feature, you should parse the file with read\_csv using the kw: quoting=3.

\end{fulllineitems}

\index{read\_site() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.read_site}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{read\_site}}{\emph{sitefile}}{}
Reads .site configuration file, which holds siteConfig definitions
\begin{description}
\item[{The .site should have definitions as regular python syntax (in meters!):}] \leavevmode
measurement\_height  = 10
canopy\_height       = 5
displacement\_height = 3
roughness\_length    = 1.0

\item[{sitedile: str}] \leavevmode
path to .site file

\end{description}

\end{fulllineitems}

\index{timeSeries() (in module pymicra.io)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.io.timeSeries}\pysiglinewithargsret{\sphinxcode{pymicra.io.}\sphinxbfcode{timeSeries}}{\emph{flist}, \emph{datalogger}, \emph{parse\_dates=True}, \emph{verbose=False}, \emph{read\_data\_kw=\{\}}, \emph{parse\_dates\_kw=\{\}}, \emph{clean\_dates=True}, \emph{return\_units=True}, \emph{only\_named\_cols=True}}{}
Creates a micrometeorological time series from a file or list of files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{flist}} (\emph{\texttt{list or string}}) -- either list or names of files (dataFrame will be one concatenated dataframe) or the name of one file

\item {} 
\textbf{\texttt{datalogger}} (\emph{\texttt{pymicra.dataloggerConfig object}}) -- configuration of the datalogger which is from where all the configurations of the file will be taken

\item {} 
\textbf{\texttt{parse\_date}} (\emph{\texttt{bool}}) -- whether or not to index the data by date. Note that if this is False many of the functionalities
of pymicra will be lost.
(i.d. there are repeated timestamps)

\item {} 
\textbf{\texttt{verbose}} (\emph{\texttt{int, bool}}) -- verbose level

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.methods module}
\label{pymicra:module-pymicra.methods}\label{pymicra:pymicra-methods-module}\index{pymicra.methods (module)}\index{binwrapper() (in module pymicra.methods)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.methods.binwrapper}\pysiglinewithargsret{\sphinxcode{pymicra.methods.}\sphinxbfcode{binwrapper}}{\emph{self}, \emph{clean\_index=True}, \emph{**kwargs}}{}
Method to return binned data from a dataframe using the function classbin

\end{fulllineitems}



\section{pymicra.physics module}
\label{pymicra:pymicra-physics-module}\label{pymicra:module-pymicra.physics}\index{pymicra.physics (module)}
Author: Tomas Chor

Module that contains physical functions for general use

TO DO LIST:
\begin{itemize}
\item {} 
ADD GENERAL SOLAR ZENITH CALCULATION

\item {} 
ADD FOOTPRINT CALCULATION?

\end{itemize}
\index{CtoK() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.CtoK}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{CtoK}}{\emph{T}}{}
Return temp in Kelvin given temp T in Celsius

\end{fulllineitems}

\index{R\_moistAir() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.R_moistAir}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{R\_moistAir}}{\emph{q}}{}
Calculates the gas constant for umid air from the specific humidity q
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{q}} (\emph{\texttt{float}}) -- the specific humidity in g(water)/g(air)

\item[{Returns}] \leavevmode
\textbf{R\_air} -- the specific gas constant for humid air in J/(g*K)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{airDensity\_from\_theta() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.airDensity_from_theta}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{airDensity\_from\_theta}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace=True}, \emph{use\_means=False}, \emph{theta=None}, \emph{theta\_unit=None}}{}
Calculates moist air density using theta measurements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset to add rho\_air

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.notation}}) -- notation to be used

\item {} 
\textbf{\texttt{inplace}} (\emph{\texttt{bool}}) -- whether or not to treat units inplace

\item {} 
\textbf{\texttt{use\_means}} (\emph{\texttt{bool}}) -- use the mean of theta or not when calculating

\item {} 
\textbf{\texttt{theta}} (\emph{\texttt{pandas.Series}}) -- auxiliar theta measurement

\item {} 
\textbf{\texttt{theta\_unit}} (\emph{\texttt{pint.quantity}}) -- auxiliar theta's unit

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{airDensity\_from\_theta\_v() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.airDensity_from_theta_v}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{airDensity\_from\_theta\_v}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace=True}, \emph{use\_means=False}}{}
Calculates moist air density using p = rho R\_dry T\_virtual

\end{fulllineitems}

\index{dewPointTemp() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.dewPointTemp}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{dewPointTemp}}{\emph{theta}, \emph{e}}{}
Calculates the dew point temperature.
theta has to be in Kelvin and e in kPa

\end{fulllineitems}

\index{dryAirDensity\_from\_p() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.dryAirDensity_from_p}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{dryAirDensity\_from\_p}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{inplace=True}}{}
Calculates dry air density
NEEDS IMPROVEMENT REGARDING HANDLING OF UNITS

\end{fulllineitems}

\index{latent\_heat\_water() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.latent_heat_water}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{latent\_heat\_water}}{\emph{T}}{}
Calculates the latent heat of evaporation for water

Receives T in Kelvin and returns the latent heat in J/g

\end{fulllineitems}

\index{perfGas() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.perfGas}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{perfGas}}{\emph{p=None}, \emph{rho=None}, \emph{R=None}, \emph{T=None}, \emph{gas=None}}{}
Returns the only value that is not provided in the ideal gas law

P.S.: I'm using type to identify None objects because this way it works
againt pandas objects

\end{fulllineitems}

\index{ppxv2density() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.ppxv2density}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{ppxv2density}}{\emph{ser}, \emph{T}, \emph{p}, \emph{units}, \emph{solute=None}}{}
ser should be a series!
concentration in ser should be ppmv, which will be transformed to g/m3
p should be in kPa!

\end{fulllineitems}

\index{satWaterPressure() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.satWaterPressure}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{satWaterPressure}}{\emph{T}, \emph{unit='kelvin'}}{}
Returns the saturated water vapor pressure according eq (3.97) of Wallace and Hobbes, page 99.

e0, b, T1 and T2 are constants specific for water vapor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{T}} (\emph{\texttt{float}}) -- thermodynamic temperature

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
saturated vapor pressure of water (in kPa)

\end{description}\end{quote}

\end{fulllineitems}

\index{solarZenith() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.solarZenith}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{solarZenith}}{\emph{date}, \emph{lat=-3.13}, \emph{lon=-60.016667}, \emph{lon0=-63.0}, \emph{negative=False}, \emph{dr=None}}{}
Calculates the solar zenith angle at any given day

needs validation and needs to work without lon0
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{date}} (\emph{\texttt{datetime object}}) -- the date and time for which the zenith angle has to be calculated

\item {} 
\textbf{\texttt{lat}} (\emph{\texttt{float}}) -- latitude in degrees

\item {} 
\textbf{\texttt{lon}} (\emph{\texttt{float}}) -- longitude in degrees

\item {} 
\textbf{\texttt{lon0}} (\emph{\texttt{float}}) -- DEFINE IT BETTER

\item {} 
\textbf{\texttt{is the julian day of the solstice. Default is to get from dictionary}} (\emph{\texttt{dr}}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{zen\_ang} -- the zenith angle in degrees

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{theta\_from\_theta\_s() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_from_theta_s}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_from\_theta\_s}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{return\_df=True}}{}
Calculates thermodynamic temperature using sonic temperature measurements

From Schotanus, Nieuwstadt, de Bruin; DOI 10.1007/BF00164332

theta\_s = theta (1 + 0.51 q) (1 - (vn/c)**2)\textasciicircum{}0.5

\(theta_s \approx theta (1 + 0.51 q)\)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- dataset

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
thermodynamic temperature

\item[{Return type}] \leavevmode
pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{theta\_from\_theta\_v() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_from_theta_v}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_from\_theta\_v}}{\emph{data}, \emph{units}, \emph{notation=None}, \emph{return\_df=True}}{}
theta\_v \textasciitilde{} theta (1 + 0.61 q)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- dataset

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{theta\_std\_from\_theta\_v\_fluc() (in module pymicra.physics)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.physics.theta_std_from_theta_v_fluc}\pysiglinewithargsret{\sphinxcode{pymicra.physics.}\sphinxbfcode{theta\_std\_from\_theta\_v\_fluc}}{\emph{data}, \emph{units}, \emph{notation=None}}{}
Derived from theta\_v = theta(1 + 0.61 q)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- dataframe with q, q', theta, theta\_v'

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- units dictionary

\item {} 
\textbf{\texttt{notation}} (\emph{\texttt{pymicra.Notation}}) -- Notation object or None

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.tests module}
\label{pymicra:pymicra-tests-module}\label{pymicra:module-pymicra.tests}\index{pymicra.tests (module)}\index{check\_RA() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_RA}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_RA}}{\emph{data}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{RAT\_vars=None}, \emph{RAT\_points=50}, \emph{RAT\_significance=0.05}}{}
Performs the Reverse Arrangement Test in each column of data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- to apply RAT to each column

\item {} 
\textbf{\texttt{detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend

\item {} 
\textbf{\texttt{RAT\_vars}} -- list of variables to which apply the RAT

\item {} 
\textbf{\texttt{RAT\_points}} (\emph{\texttt{int}}) -- if it's an int N, then reduce each column to N points by averaging. If None,
then the whole columns are used

\item {} 
\textbf{\texttt{RAT\_significance}} (\emph{\texttt{float}}) -- significance with which to apply the RAT

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{valid} -- True or False for each column. If True, column passed the test

\item[{Return type}] \leavevmode
pd.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_limits() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_limits}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_limits}}{\emph{data}, \emph{tables}, \emph{max\_percent=1.0}, \emph{replace\_with='interpolation'}}{}
Checks dataframe for lower and upper limits. If found, they are substituted by
the linear trend of the run. The number of faulty points is also checked for each
column against the maximum percentage of accepted faults max\_percent
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas dataframe}}) -- dataframe to be checked

\item {} 
\textbf{\texttt{tables}} (\emph{\texttt{pandas.dataframe}}) -- dataframe with the lower and upper limits for variables

\item {} 
\textbf{\texttt{max\_percent}} (\emph{\texttt{float}}) -- number from 0 to 100 that represents the maximum percentage of faulty
runs accepted by this test.

\item {} 
\textbf{\texttt{Return}} -- 

\item {} 
\textbf{\texttt{-{-}-{-}-{-}-}} -- 

\item {} 
\textbf{\texttt{df}} (\emph{\texttt{pandas.DataFrame}}) -- input data but with the faulty points substituted by the linear trend of the run.

\item {} 
\textbf{\texttt{valid}} (\emph{\texttt{pandas.Series}}) -- True for the columns that passed this test, False for the columns that didn't.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_maxdif() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_maxdif}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_maxdif}}{\emph{data}, \emph{tables}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}}{}
Check the maximum and minimum differences between the fluctuations of a run.

\end{fulllineitems}

\index{check\_nans() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_nans}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_nans}}{\emph{data}, \emph{max\_percent=0.1}, \emph{replace\_with='interpolation'}}{}
Checks data for NaN values

\end{fulllineitems}

\index{check\_numlines() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_numlines}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_numlines}}{\emph{fname}, \emph{numlines=18000}, \emph{falseverbose=False}}{}
Checks length of file against a correct value.
Returns False is length is wrong and True if length is right
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fname}} (\emph{\texttt{string}}) -- path of the file to check

\item {} 
\textbf{\texttt{numlines}} (\emph{\texttt{int}}) -- correct number of lines that the file has to have

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_replaced() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_replaced}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_replaced}}{\emph{replaced}, \emph{max\_count=180}}{}
Sums and checks if the number of replaced points is larger than the
maximum accepted

\end{fulllineitems}

\index{check\_spikes() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_spikes}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_spikes}}{\emph{data}, \emph{chunk\_size=`2min'}, \emph{detrend=True}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{visualize=False}, \emph{vis\_col=1}, \emph{max\_consec\_spikes=3}, \emph{cut\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{replace\_with='interpolation'}, \emph{max\_percent=1.0}}{}
Applies spikes-check according to Vickers and Mahrt (1997)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.dataframe}}) -- data to de-spike

\item {} 
\textbf{\texttt{chunk\_size}} (\emph{\texttt{str, int}}) -- size of chunks to consider. If str should be pandas offset string. If int, number of lines.

\item {} 
\textbf{\texttt{detrend}} (\emph{\texttt{bool}}) -- whether to detrend the data and work  with the fluctuations or to work with the absolute series.

\item {} 
\textbf{\texttt{detrend\_kw}} (\emph{\texttt{dict}}) -- dict of keywords to pass to pymicra.trend in order to detrend data (if detrend==True).

\item {} 
\textbf{\texttt{visualize}} (\emph{\texttt{bool}}) -- whether of not to visualize the interpolation ocurring

\item {} 
\textbf{\texttt{vis\_col}} (\emph{\texttt{str, int or list}}) -- the column(s) to visualize when seeing the interpolation (only effective if visualize==True)

\item {} 
\textbf{\texttt{max\_consec\_spikes}} (\emph{\texttt{int}}) -- maximum number of consecutive spikes to actually be considered spikes and substituted

\item {} 
\textbf{\texttt{cut\_func}} (\emph{\texttt{function}}) -- function used to define spikes

\item {} 
\textbf{\texttt{replace\_with}} (\emph{\texttt{str}}) -- method to use when replacing spikes. Options are `interpolation' or `trend'.

\item {} 
\textbf{\texttt{max\_percent}} (\emph{\texttt{float}}) -- maximum percentage of spikes to allow.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_stationarity() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_stationarity}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_stationarity}}{\emph{data}, \emph{tables}, \emph{detrend=False}, \emph{detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{trend=True}, \emph{trend\_kw=\{`how': `movingmedian'}, \emph{`window': `1min'\}}}{}
Check difference between the maximum and minimum values of the run trend agaisnt an upper-limit.
This aims to flag nonstationary runs

\end{fulllineitems}

\index{check\_std() (in module pymicra.tests)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.tests.check_std}\pysiglinewithargsret{\sphinxcode{pymicra.tests.}\sphinxbfcode{check\_std}}{\emph{data}, \emph{tables}, \emph{detrend=False}, \emph{detrend\_kw=\{`how': `linear'\}}, \emph{chunk\_size=`2min'}, \emph{falseverbose=False}}{}
Checks dataframe for columns with too small of a standard deviation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{pandas.DataFrame}}) -- dataset whose standard deviation to check

\item {} 
\textbf{\texttt{tables}} (\emph{\texttt{pandas.DataFrame}}) -- dataset containing the standard deviation limits for each column

\item {} 
\textbf{\texttt{detrend}} (\emph{\texttt{bool}}) -- whether to work with the absolute series and the fluctuations

\item {} 
\textbf{\texttt{detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend with detrend==True

\item {} 
\textbf{\texttt{chunk\_size}} (\emph{\texttt{str}}) -- pandas datetime offset string

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{valid} -- contatining True of False for each column. True means passed the test.

\item[{Return type}] \leavevmode
pandas.Series

\end{description}\end{quote}

\end{fulllineitems}



\section{pymicra.util module}
\label{pymicra:module-pymicra.util}\label{pymicra:pymicra-util-module}\index{pymicra.util (module)}
Module for general utilities
\begin{itemize}
\item {} 
INCLUDE DECODIFICAION OF DATA?

\item {} 
INCLUDE UPPER LIMIT TO STD TEST?

\item {} 
INCLUDE DROPOUT TEST

\item {} 
INCLUDE THIRD MOMENT TEST

\item {} 
CHANGE NOTATION IN QCONTROL'S SUMMARY

\end{itemize}
\index{correctDrift() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.correctDrift}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{correctDrift}}{\emph{drifted}, \emph{correct\_drifted\_vars=None}, \emph{correct=None}, \emph{get\_fit=True}, \emph{write\_fit=True}, \emph{fit\_file='correctDrift\_linfit.params'}, \emph{apply\_fit=True}, \emph{show\_plot=False}, \emph{return\_plot=False}, \emph{units=\{\}}, \emph{return\_index=False}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{correct}} (\emph{\texttt{pandas.DataFrame}}) -- dataset with the correct averages

\item {} 
\textbf{\texttt{drifted}} (\emph{\texttt{pandas.DataFrame}}) -- dataset with the averages that need to be corrected

\item {} 
\textbf{\texttt{correct\_drifted\_vars}} (\emph{\texttt{dict}}) -- dictionary where every key is a var in the right dataset and
its value is its correspondent in the drifted dataset

\item {} 
\textbf{\texttt{get\_fit}} (\emph{\texttt{bool}}) -- whether ot not to fit a linear relation between both datasets. Generally slow. Should only be done once

\item {} 
\textbf{\texttt{write\_fit}} (\emph{\texttt{bool}}) -- if get\_fit == True, whether or not to write the linear fit to a file (recommended)

\item {} 
\textbf{\texttt{fit\_file}} (\emph{\texttt{string}}) -- where to write the linear fit (if one is written) or from where to read the linear fit (if no fit is written)

\item {} 
\textbf{\texttt{apply\_fit}} (\emph{\texttt{bool}}) -- whether of not to apply the lineat fit and correct the data (at least get\_fit and fit\_file must be true)

\item {} 
\textbf{\texttt{show\_plot}} (\emph{\texttt{bool}}) -- whether or not to show drifted vs correct plot, to see if it's a good fit

\item {} 
\textbf{\texttt{units}} (\emph{\texttt{dict}}) -- if given, it creates a \{file\_file\}.units file, to tell write down in which units data has to be in
order to be correctly corrected

\item {} 
\textbf{\texttt{return\_index}} (\emph{\texttt{bool}}) -- whether to return the indexes of the used points for the calculation. Serves to check the regression

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{outdf} -- drifted dataset corrected with right dataset

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{qcontrol() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.qcontrol}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{qcontrol}}{\emph{files}, \emph{datalogger\_config}, \emph{read\_files\_kw=\{`parse\_dates': False}, \emph{`only\_named\_cols': False}, \emph{`clean\_dates': False\}}, \emph{accepted\_nans\_percent=1.0}, \emph{accepted\_spikes\_percent=1.0}, \emph{accepted\_bound\_percent=1.0}, \emph{max\_replacement\_count=180}, \emph{file\_lines=None}, \emph{begin\_date=None}, \emph{end\_date=None}, \emph{nans\_test=True}, \emph{maxdif\_detrend=True}, \emph{maxdif\_detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{maxdif\_trend=True}, \emph{maxdif\_trend\_kw=\{`how': `movingmedian'}, \emph{`window': 600\}}, \emph{std\_detrend=True}, \emph{std\_detrend\_kw=\{`how': `movingmean'}, \emph{`window': 900\}}, \emph{RAT\_detrend=True}, \emph{RAT\_detrend\_kw=\{`how': `linear'\}}, \emph{spikes\_detrend=True}, \emph{spikes\_detrend\_kw=\{`how': `linear'\}}, \emph{lower\_limits=\{\}}, \emph{upper\_limits=\{\}}, \emph{spikes\_test=True}, \emph{visualize\_spikes=False}, \emph{spikes\_vis\_col='u'}, \emph{spikes\_func=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}, \emph{replace\_with='interpolation'}, \emph{max\_consec\_spikes=3}, \emph{chunk\_size=1200}, \emph{std\_limits=\{\}}, \emph{dif\_limits=\{\}}, \emph{RAT=False}, \emph{RAT\_vars=None}, \emph{RAT\_points=50}, \emph{RAT\_significance=0.05}, \emph{trueverbose=False}, \emph{falseverbose=True}, \emph{falseshow=False}, \emph{trueshow=False}, \emph{trueshow\_vars=None}, \emph{outdir='quality\_controlled'}, \emph{summary\_file='qcontrol\_summary.csv'}, \emph{replaced\_report=None}, \emph{full\_report=None}}{}
Function that applies various tests quality control to a set of datafiles and re-writes
the successful files in another directory. A list of currently-applied tests is found
below in order of application. The only test available by default is the spikes test.
All others depend on their respective keywords.
\begin{quote}\begin{description}
\item[{Consistency tests}] \leavevmode
\end{description}\end{quote}
\begin{itemize}
\item {} \begin{quote}\begin{description}
\item[{date check}] \leavevmode
files outside a date\_range are left out (end\_date and begin\_date keywords)

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{lines test}] \leavevmode
checks each file to see if they have a certain number of lines. Files with a different number of lines
fail this test. Active this test by passing the file\_lines keyword.

\end{description}\end{quote}

\end{itemize}
\begin{quote}\begin{description}
\item[{Quality tests (in this order)}] \leavevmode
\end{description}\end{quote}
\begin{itemize}
\item {} \begin{quote}\begin{description}
\item[{NaN's test}] \leavevmode
checks for any NaN values. NaNs are replaced with interpolation or linear trend. If the percentage
of NaNs is greater than accepted\_nans\_percent, run is discarded. Activate it by passing nans\_test=True.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{boundaries test}] \leavevmode
runs with values in any column lower than a pre-determined lower limit or higher
than a upper limits are left out. Activate it by passing a lower\_limits or upper\_limits keyword.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{spikes test}] \leavevmode
runs with more than a certain percetage of spikes are left out.
Activate it by passing a spikes\_test keyword. Adjust the test with the spikes\_func
visualize\_spikes, spikes\_vis\_col, max\_consec\_spikes, accepted\_spikes\_percent and chunk\_size keywords.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{replacement count test}] \leavevmode
checks the total amount of points that were replaced (including NaN, boundaries and spikes test)
against the max\_replacement\_count keyword. Fails if any columns has more replacements than that.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{standard deviation (STD) check}] \leavevmode
runs with a standard deviation lower than a pre-determined value (generally close to the
sensor precision) are left out.
Activate it by passing a std\_limits keyword.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{maximum difference test}] \leavevmode
runs whose trend have a maximum difference greater than a certain value are left out.
This excludes non-stationary runs. Activate it by passing a dif\_limits keyword.

\end{description}\end{quote}

\item {} \begin{quote}\begin{description}
\item[{reverse arrangement test (RAT)}] \leavevmode
runs that fail the reverse arrangement test for any variable are left out.
Activate it by passing a RAT keyword.

\end{description}\end{quote}

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{files}} (\emph{\texttt{list}}) -- list of filepaths

\item {} 
\textbf{\texttt{datalogger\_config}} (\emph{\texttt{pymicra.datalogerConf object or str}}) -- datalogger configuration object used for all files in the list of files or path to a dlc file.

\item {} 
\textbf{\texttt{read\_files\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.timeSeries. Default is \{`parse\_dates':False\} because parsing dates
at every file is slow, so this makes the whole process faster.
However, \{`parse\_dates':True, `clean\_dates':False\} is recommended if time is not a problem because
the window and chunk\_size keywords may be used as, for example `2min', instead of 1200, which is the
equivalent number of points.

\item {} 
\textbf{\texttt{file\_lines}} (\emph{\texttt{int}}) -- number of line a ``good'' file must have. Fails if the run has any other number of lines.

\item {} 
\textbf{\texttt{begin\_date}} (\emph{\texttt{str}}) -- dates before this automatically fail.

\item {} 
\textbf{\texttt{end\_date}} (\emph{\texttt{str}}) -- dates after this automatically fail.

\item {} 
\textbf{\texttt{std\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be upper limits for the standard deviation.

\item {} 
\textbf{\texttt{std\_detrend}} (\emph{\texttt{bool}}) -- whether or not to work with the fluctations of the data on the spikes and standard deviation test.

\item {} 
\textbf{\texttt{std\_detrend\_kw}} -- keywords to be passed to pymicra.detrend specifically to be used on the STD test.

\item {} 
\textbf{\texttt{lower\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be lower absolute limits for the values of each var.

\item {} 
\textbf{\texttt{upper\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be upper absolute limits for the values of each var.

\item {} 
\textbf{\texttt{dif\_limits}} (\emph{\texttt{dict}}) -- keys must be names of variables and values must be upper limits for the maximum difference
of values that the linear trend of the run must have.

\item {} 
\textbf{\texttt{maxdif\_detrend}} (\emph{\texttt{bool}}) -- whether to detrend data before checking for differences.

\item {} 
\textbf{\texttt{maxdif\_detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend when detrending for max difference test.

\item {} 
\textbf{\texttt{maxdif\_trend}} (\emph{\texttt{bool}}) -- whether to check for differences using the trend, instead of raw points (which can be the fluctuations
or the original absolute values of data, depending if maxdif\_detrend==True or False).

\item {} 
\textbf{\texttt{maxdif\_trend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend when trending for max difference test.
dictionary of keywords to pass to pymicra.data.trend. This is used in the max difference test, since
the difference is taken between the max and min values of the trend, not of the series.
Default = \{`how':'linear'\}.

\item {} 
\textbf{\texttt{spikes\_test}} (\emph{\texttt{bool}}) -- whether or not to check for spikes.

\item {} 
\textbf{\texttt{spikes\_detrend}} (\emph{\texttt{bool}}) -- whether or not to work with the fluctations of the data on the spikes test.

\item {} 
\textbf{\texttt{spikes\_detrend\_kw}} (\emph{\texttt{dict}}) -- keywords to pass to pymicra.detrend when detrending for spikes.

\item {} 
\textbf{\texttt{visualize\_spikes}} (\emph{\texttt{bool}}) -- whether or not to plot the spikes identification and interpolation (useful for calibration of spikes\_func). Only
one column is visualized at each time. This is set with the spikes\_vis\_col keyword.

\item {} 
\textbf{\texttt{spikes\_vis\_col}} (\emph{\texttt{str}}) -- column to use to visualize spikes.

\item {} 
\textbf{\texttt{spikes\_func}} (\emph{\texttt{function}}) -- function used to look for spikes. Can be defined used numpy/pandas notation for methods with lambda functions.
Default is: lambda x: (abs(x - x.mean()) \textgreater{} abs(x.std()*4.))

\item {} 
\textbf{\texttt{replace\_with}} (\emph{\texttt{str}}) -- method to use when replacing the spikes. Options are `interpolation' and `trend'.

\item {} 
\textbf{\texttt{max\_consec\_spikes}} (\emph{\texttt{int}}) -- limit of consecutive spike points to be interpolated. After this spikes are left as they are in the output.

\item {} 
\textbf{\texttt{accepted\_percent}} (\emph{\texttt{float}}) -- limit percentage of spike points in the data. If spike points represent a higher percentage
than the run fails the spikes check.

\item {} 
\textbf{\texttt{chunk\_size}} (\emph{\texttt{str}}) -- string representing time length of chunks used in the spikes and standard deviation check. Default is ``2Min''.
Putting None will not separate in chunks. It's recommended to use rolling functions in this case (might be slow).

\item {} 
\textbf{\texttt{RAT}} (\emph{\texttt{bool}}) -- whether or not to perform the reverse arrangement test on data.

\item {} 
\textbf{\texttt{RAT\_vars}} (\emph{\texttt{list}}) -- list containing the name of variables to go through the reverse arrangement test. If None, all variables are tested.

\item {} 
\textbf{\texttt{RAT\_points}} (\emph{\texttt{int}}) -- number of final points to apply the RAT. If 50, the run will be averaged to a 50-points run.

\item {} 
\textbf{\texttt{RAT\_significance}} -- significance level to apply the RAT.

\item {} 
\textbf{\texttt{RAT\_detrend\_kw}} -- keywords to be passed to pymicra.detrend specifically to be used on the RA test. \{``how'':''linear''\}
is strongly recommended for this case.

\item {} 
\textbf{\texttt{trueverbose}} (\emph{\texttt{bool}}) -- whether or not to show details on the successful runs.

\item {} 
\textbf{\texttt{falseverbose}} (\emph{\texttt{bool}}) -- whether or not to show details on the failed runs.

\item {} 
\textbf{\texttt{trueshow}} (\emph{\texttt{bool}}) -- whether of not to plot the successful runs on screen.

\item {} 
\textbf{\texttt{trueshow\_vars}} (\emph{\texttt{list}}) -- list of columns to plot if run is successfull.

\item {} 
\textbf{\texttt{falseshow}} (\emph{\texttt{bool}}) -- whether of not to plot the failed runs on screen.

\item {} 
\textbf{\texttt{outdir}} (\emph{\texttt{str}}) -- name of directory in which to write the successful runs. Directory must already exist.

\item {} 
\textbf{\texttt{summary\_file}} (\emph{\texttt{str}}) -- path of file to be created with the summary of the runs. Will be overwriten if already exists.

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{ext\_summary} -- dict with the extended summary, which has the path of the files that got ``stuck'' in each test along with the successful ones

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{separateFiles() (in module pymicra.util)}

\begin{fulllineitems}
\phantomsection\label{pymicra:pymicra.util.separateFiles}\pysiglinewithargsret{\sphinxcode{pymicra.util.}\sphinxbfcode{separateFiles}}{\emph{files}, \emph{dlconfig}, \emph{outformat='out\_\%Y-\%m-\%d\_\%H:\%M.csv'}, \emph{outdir='`}, \emph{verbose=False}, \emph{firstflag='.first'}, \emph{lastflag='.last'}, \emph{save\_ram=False}, \emph{frequency=`30min'}, \emph{quoting=0}, \emph{use\_edges=False}}{}
Separates files into (default) 30-minute smaller files. Useful for output files such
as the ones by Campbell Sci, that can have days of data in one single file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{files}} (\emph{\texttt{list}}) -- list of file paths to be separated

\item {} 
\textbf{\texttt{dlconfig}} (\emph{\texttt{pymicra datalogger configuration file}}) -- to tell how the dates are displayed inside the file

\item {} 
\textbf{\texttt{outformat}} (\emph{\texttt{str}}) -- the format of the file names to output

\item {} 
\textbf{\texttt{outdir}} (\emph{\texttt{str}}) -- the path to the directory in which to output the files

\item {} 
\textbf{\texttt{verbose}} (\emph{\texttt{bool}}) -- whether to print to the screen

\item {} 
\textbf{\texttt{firstflag}} (\emph{\texttt{str}}) -- flag to put after the name of the file for the first file to be created

\item {} 
\textbf{\texttt{lastflag}} (\emph{\texttt{str}}) -- flag to put after the name of the fle for the last file to be created

\item {} 
\textbf{\texttt{save\_ram}} (\emph{\texttt{bool}}) -- if you have an amount of files that are to big for pandas to load on your ram this should be set to true

\item {} 
\textbf{\texttt{frequency}} -- the frequency in which to separate

\item {} 
\textbf{\texttt{quoting}} (\emph{\texttt{int}}) -- for pandas (see read\_csv documentation)

\item {} 
\textbf{\texttt{edges}} (\emph{\texttt{use}}) -- use this carefully. This concatenates the last few lines of a file to the first few lines
of the next file in case they don't finish on a nice round time with respect to the frequency

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\section{Module contents}
\label{pymicra:module-pymicra}\label{pymicra:module-contents}\index{pymicra (module)}

\subsection{Pymicra - Python Micrometeorology Analysis tool}
\label{pymicra:pymicra-python-micrometeorology-analysis-tool}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Tomas Chor

\item[{Date of start}] \leavevmode
2015-08-15

\end{description}\end{quote}
\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pymicra}}, \pageref{pymicra:module-pymicra}
\item {\texttt{pymicra.constants}}, \pageref{pymicra:module-pymicra.constants}
\item {\texttt{pymicra.core}}, \pageref{pymicra:module-pymicra.core}
\item {\texttt{pymicra.data}}, \pageref{pymicra:module-pymicra.data}
\item {\texttt{pymicra.decorators}}, \pageref{pymicra:module-pymicra.decorators}
\item {\texttt{pymicra.io}}, \pageref{pymicra:module-pymicra.io}
\item {\texttt{pymicra.methods}}, \pageref{pymicra:module-pymicra.methods}
\item {\texttt{pymicra.physics}}, \pageref{pymicra:module-pymicra.physics}
\item {\texttt{pymicra.tests}}, \pageref{pymicra:module-pymicra.tests}
\item {\texttt{pymicra.util}}, \pageref{pymicra:module-pymicra.util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
